#!/usr/bin/env python3
import json
import os
import sys
import argparse
import networkx as nx
from collections import defaultdict

# Mapping from SharpHound v6 meta.type → readable type
TYPE_FROM_META = {
    "users": "User",
    "computers": "Computer",
    "groups": "Group",
    "gpos": "GPO",
    "ous": "OU",
    "domains": "Domain",
    "containers": "Container",
    "certtemplates": "Certificate Template",
    "enterprisecas": "Enterprise CA",
    "rootcas": "Root CA",
    "aiacas": "AIA CA",
    "ntauthstores": "NTAuth Store",
}

def load_json_dir(directory):
    nodes = {}
    file_count = 0
    for filename in os.listdir(directory):
        if not filename.lower().endswith('.json'):
            continue
        file_count += 1
        path = os.path.join(directory, filename)
        try:
            with open(path, 'r', encoding='utf-8') as f:
                raw = json.load(f)
                meta_type = raw.get("meta", {}).get("type", "").lower()
                obj_type = TYPE_FROM_META.get(meta_type, "Unknown")

                data = raw.get('data') or raw.get('Results') or raw.get('objects') or raw
                if not isinstance(data, list):
                    data = [data]

                for item in data:
                    oid = item.get('ObjectIdentifier')
                    if not oid:
                        continue
                    if 'ObjectType' not in item:
                        item = item.copy()
                        item['ObjectType'] = obj_type
                    nodes[oid] = item
        except Exception as e:
            print(f"Warning: Failed to parse {filename}: {e}", file=sys.stderr)
    print(f"[+] Processed {file_count} JSON files → {len(nodes)} objects loaded")
    return nodes

def build_graph(nodes):
    G = nx.MultiDiGraph()
    name_to_oid = {}

    for oid, node in nodes.items():
        props = node.get('Properties', {}) or {}
        name = props.get('name') or props.get('Name') or oid
        name = name.upper().split('@')[0]

        obj_type = (
            node.get('ObjectType') or
            node.get('Type') or
            'Unknown'
        ).capitalize()

        G.add_node(oid, name=name, type=obj_type, props=props)
        name_to_oid[name] = oid

        # Relationships
        for key in ['MemberOf', 'AdminTo', 'HasSession', 'AllowedToAct', 'HasSIDHistory']:
            rels = node.get(key, [])
            if not isinstance(rels, list):
                rels = [rels] if rels else []
            for rel in rels:
                target = rel.get('ObjectIdentifier') if isinstance(rel, dict) else rel
                if target and target in nodes:
                    G.add_edge(oid, target, label=key)

        # ACLs
        aces = node.get('Aces', [])
        for ace in aces:
            principal = ace.get('PrincipalSID') or ace.get('PrincipalObjectIdentifier')
            right = ace.get('RightName')
            if principal and right and principal in nodes:
                G.add_edge(principal, oid, label=right)

    print(f"[+] Graph: {G.number_of_nodes()} nodes, {G.number_of_edges()} edges")
    return G, name_to_oid

# ────────────────────────────────────────────────
# Analysis Functions
# ────────────────────────────────────────────────

def get_high_value_targets(G):
    keywords = [
        'domain admins', 'enterprise admins', 'schema admins', 'administrators',
        'krbtgt', 'domain controllers', 'dnsadmins', 'enterprise key admins',
        'certificate template', 'enterprise ca', 'root ca', 'ntauth',
    ]
    targets = []
    for n, d in G.nodes(data=True):
        name = d['name'].lower()
        typ = d['type'].lower()
        if any(k in name for k in keywords) or 'ca' in typ or 'template' in typ or 'ntauth' in typ:
            targets.append((n, d['name'], d['type']))
    return sorted(targets, key=lambda x: x[1])

def print_shortest_paths(G, max_paths=5):
    print("\n=== Shortest Paths to High-Value Targets ===")
    users = [n for n, d in G.nodes(data=True) if d['type'] == 'User']
    targets = get_high_value_targets(G)

    if not targets:
        print("  No high-value targets found")
        return

    for tid, tname, ttype in targets:
        print(f"\nTarget: {tname} ({ttype})")
        count = 0
        for source in users:
            if source == tid or not nx.has_path(G, source, tid):
                continue
            try:
                path = nx.shortest_path(G, source, tid)
                print("  " + " → ".join(G.nodes[n]['name'] for n in path))
                count += 1
                if count >= max_paths:
                    break
            except nx.NetworkXNoPath:
                pass
        if count == 0:
            print("    No paths found")

def print_dangerous_permissions(G):
    print("\n=== Dangerous Permissions on High-Value Objects ===")
    dangerous_rights = {
        'GenericAll', 'Owns', 'WriteDacl', 'WriteOwner', 'AllExtendedRights',
        'GenericWrite', 'AddMember', 'ResetPassword', 'ForceChangePassword',
        'ManageCA', 'ManageCertificates', 'Enroll', 'CertificateEnroll', 'WriteProperty'
    }
    targets = get_high_value_targets(G)
    found = False

    for tid, tname, ttype in targets:
        incoming = G.in_edges(tid, data=True)
        dangerous_edges = [
            (u, d['label']) for u, v, d in incoming if d['label'] in dangerous_rights
        ]
        if dangerous_edges:
            found = True
            print(f"\n{tname} ({ttype}):")
            for principal_oid, right in dangerous_edges:
                principal_name = G.nodes[principal_oid]['name']
                print(f"  • {principal_name} --[{right}]--> {tname}")
    if not found:
        print("  No dangerous ACLs found on high-value objects")

def print_unconstrained_delegation(G):
    print("\n=== Unconstrained Delegation ===")
    found = False
    for n, d in G.nodes(data=True):
        props = d.get('props', {})
        if props.get('unconstraineddelegation', False):
            found = True
            print(f"  • {d['name']} ({d['type']})")
    if not found:
        print("  None found")

def print_kerberoastable(G):
    print("\n=== Kerberoastable Accounts ===")
    found = False
    for n, d in G.nodes(data=True):
        if d['type'] != 'User':
            continue
        props = d.get('props', {})
        if props.get('hasspn', False) and not props.get('sensitive', False) and props.get('enabled', True):
            found = True
            print(f"  • {d['name']}")
    if not found:
        print("  None found")

def print_as_rep_roastable(G):
    print("\n=== AS-REP Roastable Accounts (DONT_REQ_PREAUTH) ===")
    found = False
    for n, d in G.nodes(data=True):
        if d['type'] != 'User':
            continue
        props = d.get('props', {})
        if props.get('dontreqpreauth', False) and props.get('enabled', True):
            found = True
            print(f"  • {d['name']}")
    if not found:
        print("  None found")

def print_verbose_summary(G):
    print("\n=== VERBOSE SUMMARY ===")
    types_count = defaultdict(int)
    for _, d in G.nodes(data=True):
        types_count[d['type']] += 1

    print("\nObject Types:")
    for t, cnt in sorted(types_count.items(), key=lambda x: x[1], reverse=True):
        print(f"  {t:20} {cnt}")

    users = [d['name'] for _, d in G.nodes(data=True) if d['type'] == 'User']
    print(f"\nUsers ({len(users)}):")
    for name in sorted(users)[:30]:
        print(f"  • {name}")
    if len(users) > 30:
        print(f"  ... ({len(users)-30} more)")

# ────────────────────────────────────────────────
# Main
# ────────────────────────────────────────────────

def main():
    parser = argparse.ArgumentParser(description="BloodHound JSON Analyzer (v6 support)")
    parser.add_argument('directory', nargs='?', default='.', help='Path to SharpHound JSON files')

    # Analysis flags
    parser.add_argument('--shortest-paths', action='store_true', help='Show shortest paths to high-value targets')
    parser.add_argument('--dangerous-permissions', action='store_true', help='Show dangerous ACLs on sensitive objects')
    parser.add_argument('--unconstrained-delegation', action='store_true', help='List unconstrained delegation objects')
    parser.add_argument('--kerberoastable', action='store_true', help='List kerberoastable accounts')
    parser.add_argument('--as-rep-roastable', action='store_true', help='List AS-REP roastable accounts')
    parser.add_argument('--high-value', action='store_true', help='List high-value targets only')
    parser.add_argument('--verbose', action='store_true', help='Show detailed summary')

    # Convenience
    parser.add_argument('--all', action='store_true', help='Run all analyses')

    args = parser.parse_args()

    if not os.path.isdir(args.directory):
        print(f"Error: Directory not found: {args.directory}")
        sys.exit(1)

    nodes = load_json_dir(args.directory)
    if not nodes:
        print("No valid objects found.")
        sys.exit(1)

    G, _ = build_graph(nodes)

    # Decide what to run
    run_all = args.all or not any([
        args.shortest_paths, args.dangerous_permissions, args.unconstrained_delegation,
        args.kerberoastable, args.as_rep_roastable, args.high_value
    ])

    if args.verbose or run_all:
        print_verbose_summary(G)

    if args.high_value or run_all:
        print("\n=== High-Value Targets ===")
        for _, name, typ in get_high_value_targets(G):
            print(f"  • {name} ({typ})")

    if args.shortest_paths or run_all:
        print_shortest_paths(G)

    if args.dangerous_permissions or run_all:
        print_dangerous_permissions(G)

    if args.unconstrained_delegation or run_all:
        print_unconstrained_delegation(G)

    if args.kerberoastable or run_all:
        print_kerberoastable(G)

    if args.as_rep_roastable or run_all:
        print_as_rep_roastable(G)

if __name__ == '__main__':
    main()
