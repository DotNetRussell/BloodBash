#!/usr/bin/env python3
import json
import os
import sys
import argparse
import networkx as nx
from collections import defaultdict
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.progress import Progress
from rich import print as rprint
from tqdm import tqdm
import time
import csv  # For CSV export
import sqlite3  # For database persistence
from html import escape  # For HTML export
import yaml  # For YAML export
__version__ = "1.1.0"  # Updated version for enhancements
console = Console()
# ────────────────────────────────────────────────
# Severity Scoring (for prioritization)
# ────────────────────────────────────────────────
SEVERITY_SCORES = {
    "ESC1-ESC8": 10,  # High impact, privilege escalation
    "DCSync": 10,
    "RBCD": 9,
    "Dangerous Permissions": 9,
    "SID History Abuse": 8,
    "GPO Abuse": 7,
    "Kerberoastable": 5,
    "AS-REP Roastable": 5,
    "Shortest Paths": 6,  # Depends on length
    "Password Never Expires": 4,  # Moderate risk: Old passwords may persist
    "Password Not Required": 8,   # High risk: No auth barrier
    "Shadow Credentials": 8,      # High risk: Key addition without password change
    "GPO Content": 7,             # Medium risk: Exploitable GPO settings
    "Constrained Delegation": 7,  # Medium risk: Service impersonation
    "LAPS": 6,                    # Moderate risk: Password management
}
global_findings = []  # List of (score, category, details) for prioritization
def add_finding(category, details, score=None):
    if score is None:
        score = SEVERITY_SCORES.get(category, 5)
    global_findings.append((score, category, details))
def print_prioritized_findings():
    if not global_findings:
        return
    console.rule("[bold magenta]Prioritized Findings by Severity[/bold magenta]")
    sorted_findings = sorted(global_findings, key=lambda x: x[0], reverse=True)
    table = Table(title="Findings Summary", show_header=True, header_style="bold red")
    table.add_column("Severity Score", style="red", justify="right")
    table.add_column("Category", style="cyan")
    table.add_column("Details", style="yellow")
    for score, cat, det in sorted_findings[:20]:  # Top 20
        table.add_row(str(score), cat, det)
    console.print(table)
    if len(sorted_findings) > 20:
        console.print(f"[dim]... and {len(sorted_findings) - 20} more[/dim]")
# ────────────────────────────────────────────────
# Intro Banner
# ────────────────────────────────────────────────
def print_intro_banner(mode_str):
    console.rule(f"[bold magenta]BloodBash v{__version__} - SharpHound Offline Analyzer[/bold magenta]", style="magenta")
    
    console.print(Panel(
        f"""

                                                                                             
[red]@@@@@@@   @@@        @@@@@@    @@@@@@   @@@@@@@      @@@@@@@    @@@@@@    @@@@@@   @@@  @@@[/red]  
[red]@@@@@@@@  @@@       @@@@@@@@  @@@@@@@@  @@@@@@@@     @@@@@@@@  @@@@@@@@  @@@@@@@   @@@  @@@[/red]    
[red]@@!  @@@  @@!       @@!  @@@  @@!  @@@  @@!  @@@     @@!  @@@  @@!  @@@  !@@       @@!  @@@[/red]    
[red]!@   @!@  !@!       !@!  @!@  !@!  @!@  !@!  @!@     !@   @!@  !@!  @!@  !@!       !@!  @!@[/red]    
[red]@!@!@!@   @!!       @!@  !@!  @!@  !@!  @!@  !@!     @!@!@!@   @!@!@!@!  !!@@!!    @!@!@!@![/red]    
[red]!!!@!!!!  !!!       !@!  !!!  !@!  !!!  !@!  !!!     !!!@!!!!  !!!@!!!!   !!@!!!   !!!@!!!![/red]    
[red]!!:  !!!  !!:       !!:  !!!  !!:  !!!  !!:  !!!     !!:  !!!  !!:  !!!       !:!  !!:  !!![/red]    
[red]:!:  !:!   :!:      :!:  !:!  :!:  !:!  :!:  !:!     :!:  !:!  :!:  !:!      !:!   :!:  !:![/red]    
[red] :: ::::   :: ::::  ::::: ::  ::::: ::   :::: ::      :: ::::  ::   :::  :::: ::   ::   :::[/red]    
[red]:: : ::   : :: : :   : :  :    : :  :   :: :  :      :: : ::    :   : :  :: : :     :   : :[/red]    
                                                                                             

Parses SharpHound JSON files → finds AD attack paths & misconfigurations
What it shows:
• High-value targets (admins, krbtgt, CAs, templates, NTAuth...)
• AD CS misconfigs (ESC1–ESC8)
• Dangerous ACLs & permissions (direct & indirect via groups)
• DCSync / replication rights
• RBCD opportunities
• SID history abuse
• Kerberoastable & AS-REP roastable accounts
• Weak GPO rights
• Shortest paths to high-value targets (direct & indirect)
• Local admin / session summary (when data exists)
Abuse suggestions: Shown once per vulnerable category (when found)
Common tools: Certipy, Impacket, Rubeus, Mimikatz, SharpGPOAbuse, etc.
Mode: [cyan]{mode_str}[/cyan]
For authorized security testing / red teaming only.
Use --help for all options.
""",
        title="Quick Overview",
        border_style="bright_blue",
        padding=(1, 2)
    ))
    console.print("[bold]Color guide:[/bold]")
    console.print("  [red]Red[/red]          = Critical findings (ESCs, DCSync, dangerous rights)")
    console.print("  [yellow]Yellow[/yellow]       = Medium risk (weak GPOs, roastable accounts)")
    console.print("  [green]Green[/green]        = No issues / success / principals with rights")
    console.print("  [cyan]Cyan[/cyan]         = Object names, targets, templates, types, counts")
    console.print("  [magenta]Magenta[/magenta]      = Section headers & dividers only")
    console.print("  [dim]Dim[/dim]          = Minor notes or empty results\n")
# ────────────────────────────────────────────────
# Type Mapping (SharpHound v6+)
# ────────────────────────────────────────────────
TYPE_FROM_META = {
    "users": "User",
    "computers": "Computer",
    "groups": "Group",
    "gpos": "GPO",
    "ous": "OU",
    "domains": "Domain",
    "containers": "Container",
    "certtemplates": "Certificate Template",
    "enterprisecas": "Enterprise CA",
    "rootcas": "Root CA",
    "aiacas": "AIA CA",
    "ntauthstores": "NTAuth Store",
}
# ────────────────────────────────────────────────
# Abuse Suggestions Helper
# ────────────────────────────────────────────────
def print_abuse_panel(vuln_type: str):
    title = f"Abuse Suggestions: {vuln_type}"
    content = ""
    border = "red"
    if vuln_type == "ESC1-ESC8 (AD CS)":
        content = """
[bold red]Impact:[/bold red] Certificate-based privilege escalation (ESC1–ESC8) → impersonate users (often admins/DA), relay attacks, or obtain high-value certificates.
Common tools: Certipy[](https://github.com/ly4k/Certipy), ntlmrelayx.py (Impacket)
ESC1/ESC2/ESC6 examples:
certipy req -u lowpriv@domain.local -p 'Password!' -ca 'DOMAIN-CA' \\
    -template VulnerableTemplate -upn administrator@domain.local
ESC8 (NTAuth relay):
ntlmrelayx.py -t https://ca.domain.local/certsrv/certfnsh.asp --adcs --template VulnerableTemplate -smb2support
Warning: Requires network access to CA/DC + low-priv creds. Authorized testing only.
"""
    elif vuln_type == "DCSync":
        content = """
[bold red]Impact:[/bold red] Dump NTDS hashes (krbtgt, admins, etc.) → Golden Ticket, pass-the-hash, domain compromise.
Tools: Mimikatz or Impacket secretsdump
Mimikatz:
lsadump::dcsync /domain:domain.local /user:krbtgt
lsadump::dcsync /domain:domain.local /all /csv
Impacket:
secretsdump.py domain/user:password@dc-ip -just-dc
secretsdump.py -just-dc-ntds domain/user:password@dc-ip
"""
    elif vuln_type == "GPO Abuse":
        content = """
[bold yellow]Impact:[/bold yellow] Modify GPO → deploy malicious scheduled tasks/scripts → code execution / priv esc on affected machines.
Tools: SharpGPOAbuse, pyGPOAbuse, PowerView
SharpGPOAbuse example:
SharpGPOAbuse.exe --gponame "VulnerableGPO" --computer "target$" --taskname "EvilTask" --task "powershell.exe -c evil.ps1"
PowerView:
New-GPOImmediateTask -TaskName="Backdoor" -Command="powershell.exe ..."
"""
    elif vuln_type == "Dangerous Permissions":
        content = """
[bold red]Impact:[/bold red] Varies by right — ResetPassword → account takeover; GenericAll → full control; WriteDacl → own object.
Common abuses:
- Reset/ForceChangePassword:
  net user target NewPass123! /domain
- GenericAll on user/group:
  Add yourself or reset password
- WriteDacl:
  Grant self GenericAll then proceed
Warning: Requires control of the principal with the dangerous right.
"""
    elif vuln_type == "Kerberoastable":
        content = """
[bold yellow]Impact:[/bold yellow] Request TGS → offline crack weak service account password.
Tool: Impacket
GetUserSPNs.py -request -outputfile hashes.txt domain/user:password@domain.local
Crack:
hashcat -m 13100 hashes.txt wordlist.txt
"""
    elif vuln_type == "AS-REP Roastable":
        content = """
[bold yellow]Impact:[/bold yellow] Request AS-REP without preauth → offline crack user hash.
Tools: Rubeus or Impacket
Rubeus:
Rubeus.exe asreproast /format:hashcat /outfile:hashes.txt
Impacket:
GetNPUsers.py domain/ -usersfile users.txt -format hashcat -dc-ip dc-ip
Crack (mode 18200):
hashcat -m 18200 hashes.asreproast wordlist.txt
"""
    elif vuln_type == "RBCD":
        content = """
[bold red]Impact:[/bold red] Resource-Based Constrained Delegation → S4U2Self/S4U2Proxy impersonation.
Tool: Impacket rbcd.py
rbcd.py -delegate-from 'attacker$' -delegate-to 'target$' \\
    -action write -dc-ip dc-ip domain/user:password
Then use getST.py or Rubeus s4u.
"""
    elif vuln_type == "SID History Abuse":
        content = """
[bold yellow]Impact:[/bold yellow] If a user has SID history from a privileged group, they may retain rights.
Tool: Check with PowerView or manually verify.
Abuse: Use Mimikatz to extract SID history and impersonate.
"""
    elif vuln_type == "Unconstrained Delegation":
        content = """
[yellow]Impact:[/yellow] Computers with unconstrained delegation can impersonate any user who authenticates to them (e.g., via Kerberos tickets).
Abuse: Relay authentication to the computer, then extract TGTs to impersonate users/domain admins.
Tools: Rubeus (tgtdeleg), KrbRelay, or Impacket.
Mitigation: Enable constrained delegation or remove from domain.
"""
    elif vuln_type == "Password in Description":
        content = """
[yellow]Impact:[/yellow] Users with passwords stored in plain text in their AD description field can be exploited for credential theft.
Abuse: Extract password from description and use for lateral movement or privilege escalation.
Mitigation: Audit and remove sensitive info from descriptions; enforce policies.
"""
    if content:
        console.print(Panel(content, title=title, border_style=border))
    else:
        console.print(f"[dim]No abuse example defined for {vuln_type}[/dim]")

# ────────────────────────────────────────────────
# Loading & Graph Building
# ────────────────────────────────────────────────
def load_json_dir(directory):
    nodes = {}
    try:
        files = [f for f in os.listdir(directory) if f.lower().endswith('.json')]
    except FileNotFoundError:
        console.print(f"[yellow]Warning: Directory '{directory}' not found. Skipping.[/yellow]")
        return nodes  # Return empty dict to avoid crash
    with Progress() as progress:
        task = progress.add_task("[cyan]Loading JSON files...", total=len(files))
        for filename in files:
            path = os.path.join(directory, filename)
            try:
                with open(path, 'r', encoding='utf-8-sig') as f:
                    raw = json.load(f)
                    meta_type = raw.get("meta", {}).get("type", "").lower()
                    obj_type = TYPE_FROM_META.get(meta_type, "Unknown")
                    data = raw.get('data') or raw.get('Results') or raw.get('objects') or raw
                    if not isinstance(data, list):
                        data = [data]
                    for item in data:
                        oid = item.get('ObjectIdentifier')
                        if not oid:
                            # If no ObjectIdentifier, it's likely a relationship-only file
                            # Don't add as node, but keep the data for later edge processing
                            if 'start' in item and 'end' in item:
                                nodes[f"rel_{len(nodes)}"] = item  # temporary key
                            continue
                        if 'ObjectType' not in item and 'Type' not in item:
                            item['ObjectType'] = obj_type
                        props = item.get('Properties', {})
                        if 'type' in props and props['type']:
                            item['ObjectType'] = props['type']
                        nodes[oid] = item
            except Exception as e:
                console.print(f"[yellow]Warning: Failed to parse {filename}: {e}[/yellow]")
            progress.advance(task)
    console.print(f"[green]✓ Loaded {len(nodes)} objects from {len(files)} files[/green]")
    return nodes

def build_graph(nodes, db_path=None):
    G = nx.MultiDiGraph()
    name_to_oid = {}
    relationship_edges = []
    placeholder_counter = 0
    with tqdm(total=len(nodes), desc="Building graph", unit="node") as pbar:
        for oid, node in nodes.items():
            props = node.get('Properties', {}).copy()
            for key in ['EnrolleeSuppliesSubject', 'RequiresManagerApproval',
                        'EDITF_ATTRIBUTESUBJECTALTNAME2', 'enrolleesuppliessubject',
                        'requiresmanagerapproval', 'editf_attributesubjectaltname2']:
                if key in node:
                    props[key] = node[key]
            name = props.get('name') or props.get('Name') or oid
            name_norm = name.upper().split('@')[0]
            obj_type = (
                node.get('ObjectType') or node.get('Type') or props.get('type') or 'Unknown'
            ).capitalize()
            if not oid.startswith('rel_'):
                G.add_node(oid, name=name, type=obj_type, props=props)
                name_to_oid[name_norm] = oid
            # Handle temp rel nodes directly
            if 'start' in node and 'end' in node and 'label' in node:
                relationship_edges.append((node['start'], node['end'], node['label']))
            # Existing data_items for regular nodes
            data_items = node.get('data', []) if 'data' in node else []
            if not isinstance(data_items, list):
                data_items = [data_items] if data_items else []
            for rel in data_items:
                start = rel.get('start')
                end = rel.get('end')
                label = rel.get('label')
                if start and end and label:
                    relationship_edges.append((start, end, label))
            for key in ['MemberOf', 'AdminTo', 'HasSession', 'AllowedToAct', 'HasSIDHistory']:
                rels = node.get(key, [])
                if not isinstance(rels, list):
                    rels = [rels] if rels else []
                for rel in rels:
                    target = rel.get('ObjectIdentifier') if isinstance(rel, dict) else rel
                    if target and target in nodes:
                        G.add_edge(oid, target, label=key)
            aces = node.get('Aces', [])
            for ace in aces:
                principal = ace.get('PrincipalSID') or ace.get('PrincipalObjectIdentifier')
                right = ace.get('RightName')
                if principal and right and principal in nodes:
                    G.add_edge(principal, oid, label=right)
            pbar.update(1)
    console.print("[cyan]Processing standalone relationships...[/cyan]")
    added = 0
    placeholders_added = 0
    for start, end, label in relationship_edges:
        start_norm = start.upper().split('@')[0]
        end_norm = end.upper().split('@')[0]
        start_oid = None
        if start in G.nodes:
            start_oid = start
        elif start_norm in name_to_oid:
            start_oid = name_to_oid[start_norm]
        else:
            start_oid = f"placeholder_{placeholder_counter}"
            placeholder_counter += 1
            G.add_node(start_oid, name=start, type='Unknown', props={})
            name_to_oid[start_norm] = start_oid
            placeholders_added += 1
            console.print(f"[dim]Created placeholder node for start: {start} (OID: {start_oid})[/dim]")
        end_oid = None
        if end in G.nodes:
            end_oid = end
        elif end_norm in name_to_oid:
            end_oid = name_to_oid[end_norm]
        else:
            end_oid = f"placeholder_{placeholder_counter}"
            placeholder_counter += 1
            G.add_node(end_oid, name=end, type='Unknown', props={})
            name_to_oid[end_norm] = end_oid
            placeholders_added += 1
            console.print(f"[dim]Created placeholder node for end: {end} (OID: {end_oid})[/dim]")
        if start_oid and end_oid:
            G.add_edge(start_oid, end_oid, label=label)
            added += 1
            console.print(f"[dim]Added edge: {start_oid} --[{label}]--> {end_oid}[/dim]")
        else:
            console.print(f"[yellow]Skipped relationship {start} -> {end} ({label}): unexpected error[/yellow]")
    console.print(f"[green]Added {added} relationship edges ({placeholders_added} placeholder nodes created)[/green]")
    console.print(f"[green]✓ Graph built: {G.number_of_nodes()} nodes, {G.number_of_edges()} edges[/green]")
    # Save to DB if specified
    if db_path:
        save_graph_to_db(G, db_path)
    return G, name_to_oid
def save_graph_to_db(G, db_path):
    conn = sqlite3.connect(db_path)
    c = conn.cursor()
    c.execute('''CREATE TABLE IF NOT EXISTS nodes (oid TEXT PRIMARY KEY, name TEXT, type TEXT, props TEXT)''')
    c.execute('''CREATE TABLE IF NOT EXISTS edges (start_oid TEXT, end_oid TEXT, label TEXT)''')
    for n, d in G.nodes(data=True):
        c.execute("INSERT OR REPLACE INTO nodes VALUES (?, ?, ?, ?)", (n, d['name'], d['type'], json.dumps(d['props'])))
    for u, v, d in G.edges(data=True):
        c.execute("INSERT INTO edges VALUES (?, ?, ?)", (u, v, d['label']))
    conn.commit()
    conn.close()
    console.print(f"[green]Graph saved to DB: {db_path}[/green]")
def load_graph_from_db(db_path):
    G = nx.MultiDiGraph()
    name_to_oid = {}
    conn = sqlite3.connect(db_path)
    c = conn.cursor()
    c.execute("SELECT oid, name, type, props FROM nodes")
    for oid, name, typ, props in c.fetchall():
        G.add_node(oid, name=name, type=typ, props=json.loads(props))
        name_to_oid[name.upper().split('@')[0]] = oid
    c.execute("SELECT start_oid, end_oid, label FROM edges")
    for u, v, label in c.fetchall():
        G.add_edge(u, v, label=label)
    conn.close()
    console.print(f"[green]Graph loaded from DB: {db_path}[/green]")
    return G, name_to_oid

# ────────────────────────────────────────────────
# VERBOSE SUMMARY
# ────────────────────────────────────────────────
def print_verbose_summary(G, domain_filter=None):
    console.rule("[bold magenta]VERBOSE SUMMARY[/bold magenta]")
    types_count = defaultdict(int)
    for _, d in G.nodes(data=True):
        if domain_filter and d.get('props', {}).get('domain') != domain_filter:
            continue
        types_count[d['type']] += 1
    table = Table(title="Object Types", show_header=True, header_style="bold cyan")
    table.add_column("Type", style="green")
    table.add_column("Count", justify="right")
    for t, cnt in sorted(types_count.items(), key=lambda x: x[1], reverse=True):
        table.add_row(t, str(cnt))
    console.print(table)
    users = [d['name'] for _, d in G.nodes(data=True) if d['type'].lower() == 'user' and (not domain_filter or d.get('props', {}).get('domain') == domain_filter)]
    if users:
        console.print(f"\n[bold cyan]Users ({len(users)}):[/bold cyan]")
        for name in sorted(users)[:len(users)]:
            console.print(f"  • {name}")
    else:
        console.print("\n[yellow]No User objects found[/yellow]")

# ────────────────────────────────────────────────
# Helpers
# ────────────────────────────────────────────────
def get_bool_prop_ci(props, keys, default=False):
    """Case-insensitive boolean property getter."""
    if not isinstance(props, dict):
        return default
    for key in keys:
        for p_key in props:
            if p_key.lower() == key.lower():
                return bool(props[p_key])
    return default
def get_high_value_targets(G, domain_filter=None):
    keywords = [
        'domain admins', 'enterprise admins', 'schema admins', 'administrators',
        'krbtgt', 'domain controllers', 'dnsadmins', 'enterprise key admins',
        'certificate template', 'enterprise ca', 'root ca', 'ntauth','dc'
    ]
    targets = []
    for n, d in G.nodes(data=True):
        if domain_filter and d.get('props', {}).get('domain') != domain_filter:
            continue
        name = d['name'].lower()
        typ = d['type'].lower()
        if any(k in name for k in keywords) or 'ca' in typ or 'template' in typ or 'ntauth' in typ:
            targets.append((n, d['name'], d['type']))
    return sorted(targets, key=lambda x: x[1])
def format_path(G, path):
    if not path or len(path) < 1:
        return "[dim]Invalid path[/dim]"
    if len(path) == 1:
        return f"[bold cyan]{G.nodes[path[0]]['name']}[/bold cyan] (self)"
    parts = []
    for i in range(len(path)-1):
        u, v = path[i], path[i+1]
        edges = G.get_edge_data(u, v)
        label = next(iter(edges.values()))['label'] if edges else '???'
        parts.append(f"[bold cyan]{G.nodes[u]['name']}[/bold cyan] --[[yellow]{label}[/yellow]]-->")
    parts.append(f"[bold red]{G.nodes[path[-1]]['name']}[/bold red]")
    return " ".join(parts)
def get_indirect_paths(G, source, target, max_depth=5):
    # Simple BFS to find indirect paths through groups
    paths = []
    try:
        for path in nx.all_simple_paths(G, source, target, cutoff=max_depth):
            if len(path) > 2:  # At least one intermediate
                paths.append(path)
        return paths[:5]  # Limit
    except nx.NetworkXNoPath:
        return []

def print_password_in_descriptions(G, domain_filter=None):
    console.rule("[bold magenta]Passwords in User Descriptions[/bold magenta]")
    found = False
    # Simple regex-like patterns for common password indicators (case-insensitive)
    password_patterns = [
        r'password\s*:', r'pwd\s*:', r'pass\s*:', r'credentials\s*:', r'login\s*:',
        r'account\s*:', r'admin\s*:', r'secret\s*:', r'key\s*:'
    ]
    import re  # For regex matching
    for n, d in G.nodes(data=True):
        if domain_filter and d.get('props', {}).get('domain') != domain_filter:
            continue
        if d['type'].lower() == 'user':
            props = d.get('props') or {}  # Ensure props is always a dict
            description = (props.get('description') or '').lower()
            if description:
                for pattern in password_patterns:
                    if re.search(pattern, description, re.IGNORECASE):
                        found = True
                        console.print(f"[yellow]Potential password in description[/yellow]: [green]{d['name']}[/green] - '{props.get('description')}'")
                        add_finding("Password in Description", f"User {d['name']} has potential password in description", score=6)
                        break  # Avoid duplicate alerts per user
    if found:
        print_abuse_panel("Password in Description")  # Reuse or add panel
    else:
        console.print("[green]No passwords detected in user descriptions[/green]")

def print_password_never_expires(G, domain_filter=None):
    console.rule("[bold magenta]Users with 'Password Never Expires' Set[/bold magenta]")
    found = False
    for n, d in G.nodes(data=True):
        if domain_filter and d.get('props', {}).get('domain') != domain_filter:
            continue
        if d['type'].lower() == 'user':
            props = d.get('props') or {}
            password_never_expires = get_bool_prop_ci(props, ['passwordneverexpires', 'PasswordNeverExpires'])
            if password_never_expires:
                found = True
                console.print(f"[yellow]Password Never Expires enabled[/yellow]: [green]{d['name']}[/green]")
                add_finding("Password Never Expires", f"User {d['name']} has 'Password Never Expires' set")
    if found:
        console.print(Panel(
            "[bold yellow]Impact:[/bold yellow] Passwords may never expire, leading to old/weak passwords persisting indefinitely.\n"
            "[bold]Mitigation:[/bold] Review and enforce password policies; consider resetting passwords for affected accounts.\n"
            "[bold]Tools:[/bold] Use PowerShell (Get-ADUser) or AD tools to audit.",
            title="Abuse Suggestions: Password Never Expires",
            border_style="yellow"
        ))
    else:
        console.print("[green]No users with 'Password Never Expires' found[/green]")

def print_password_not_required(G, domain_filter=None):
    console.rule("[bold magenta]Users with 'Password Not Required' Set[/bold magenta]")
    found = False
    for n, d in G.nodes(data=True):
        if domain_filter and d.get('props', {}).get('domain') != domain_filter:
            continue
        if d['type'].lower() == 'user':
            props = d.get('props') or {}
            password_not_required = get_bool_prop_ci(props, ['passwordnotrequired', 'PasswordNotRequired'])
            if password_not_required:
                found = True
                console.print(f"[red]Password Not Required enabled[/red]: [green]{d['name']}[/green]")
                add_finding("Password Not Required", f"User {d['name']} has 'Password Not Required' set")
    if found:
        console.print(Panel(
            "[bold red]Impact:[/bold red] No password required for login, enabling easy account takeover or unauthorized access.\n"
            "[bold]Abuse:[/bold] Log in without a password; escalate privileges if account has rights.\n"
            "[bold]Mitigation:[/bold] Enforce passwords; disable or monitor such accounts.\n"
            "[bold]Tools:[/bold] ADUC, PowerShell, or BloodHound for auditing.",
            title="Abuse Suggestions: Password Not Required",
            border_style="red"
        ))
    else:
        console.print("[green]No users with 'Password Not Required' found[/green]")

def print_shadow_credentials(G, domain_filter=None):
    console.rule("[bold magenta]Shadow Credentials Detection[/bold magenta]")
    found = False
    for n, d in G.nodes(data=True):
        if domain_filter and d.get('props', {}).get('domain') != domain_filter:
            continue
        if d['type'].lower() == 'user':
            props = d.get('props') or {}
            key_credential_link = get_bool_prop_ci(props, ['keycredentiallink', 'msds-keycredentiallink', 'KeyCredentialLink'])
            if key_credential_link:
                found = True
                console.print(f"[red]Shadow Credentials detected[/red]: [green]{d['name']}[/green]")
                add_finding("Shadow Credentials", f"User {d['name']} has Shadow Credentials configured")
    if found:
        console.print(Panel(
            "[bold red]Impact:[/bold red] Allows adding keys for authentication without changing password → persistent access.\n"
            "[bold]Abuse:[/bold] Use tools like Whisker or DSInternals to add keys and impersonate.\n"
            "[bold]Mitigation:[/bold] Disable KeyCredentialLink or monitor for changes.\n"
            "[bold]Tools:[/bold] Whisker (https://github.com/eladshamir/Whisker), DSInternals.",
            title="Abuse Suggestions: Shadow Credentials",
            border_style="red"
        ))
    else:
        console.print("[green]No accounts with Shadow Credentials found[/green]")

def print_gpo_content_parsing(G, domain_filter=None):
    console.rule("[bold magenta]GPO Content Parsing for Exploitable Settings[/bold magenta]")
    
    
    found = False
    exploitable_keys = ['taskname', 'scriptpath', 'scheduledtask', 'TaskName', 'ScriptPath', 'ScheduledTask']

    for n, d in G.nodes(data=True):
        if domain_filter and d.get('props', {}).get('domain') != domain_filter:
            continue

        if d.get('type', '').lower() != 'gpo':
            continue

        name = d.get('name') or d.get('ObjectIdentifier', 'Unnamed GPO')
        props = d.get('props') or {}

        lower_props = {k.lower(): v for k, v in props.items()}

        found_keys = [k for k in exploitable_keys if k.lower() in lower_props and lower_props[k.lower()]]

        console.print(f"[dim]→ GPO {name!r} | found_keys = {found_keys}[/dim]")

        if found_keys:
            found = True
            console.print(f"[yellow]Exploitable GPO content detected[/yellow]: [bold cyan]{name}[/bold cyan]")

            for key in exploitable_keys:
                if key.lower() in lower_props:
                    value = props.get(key) or lower_props.get(key.lower())
                    console.print(f"  → [cyan]{key}[/cyan]: {value}")

            # ───────────────────────────────────────────────────────────────
            console.print("[bold yellow]>>> About to call add_finding <<< [/bold yellow]")
            try:
                detail = f"GPO '{name}' has exploitable content: {', '.join(found_keys)}"
                add_finding("GPO Content", detail)
                console.print("[bold green]>>> add_finding SUCCESSFULLY CALLED <<< [/bold green]")
            except Exception as e:
                console.print("[bold red]>>> ERROR calling add_finding: [/bold red]", str(e))
            # ───────────────────────────────────────────────────────────────

    if found:
        console.print("[yellow]At least one exploitable GPO found[/yellow]")
        # print_abuse_panel("GPO Content")  # ← comment out if noisy
    else:
        console.print("[green]No exploitable GPO content found[/green]")

def print_constrained_delegation(G, domain_filter=None):
    console.rule("[bold magenta]Constrained Delegation Detection[/bold magenta]")
    found = False
    for n, d in G.nodes(data=True):
        if domain_filter and d.get('props', {}).get('domain') != domain_filter:
            continue
        if d['type'].lower() == 'computer':
            props = d.get('props') or {}
            trusted_to_auth = get_bool_prop_ci(props, ['trustedtoauthfordelegation', 'TrustedToAuthForDelegation'])
            allowed_to_delegate_to = props.get('msds-allowedtodelegateto', []) or props.get('allowedtodelegateto', [])
            if trusted_to_auth or allowed_to_delegate_to:
                found = True
                console.print(f"[yellow]Constrained Delegation enabled[/yellow]: [bold cyan]{d['name']}[/bold cyan]")
                if allowed_to_delegate_to:
                    console.print(f"  → Allowed to delegate to: {', '.join(allowed_to_delegate_to)}")
                add_finding("Constrained Delegation", f"Computer {d['name']} has Constrained Delegation")
    if found:
        console.print(Panel(
            "[bold yellow]Impact:[/bold yellow] Allows impersonation of users to specific services.\n"
            "[bold]Abuse:[/bold] Use S4U2Self/S4U2Proxy to relay authentication.\n"
            "[bold]Mitigation:[/bold] Limit delegation targets; use resource-based constraints.\n"
            "[bold]Tools:[/bold] Rubeus, Impacket.",
            title="Abuse Suggestions: Constrained Delegation",
            border_style="yellow"
        ))
    else:
        console.print("[green]No Constrained Delegation found[/green]")

def print_laps_status(G, domain_filter=None):
    console.rule("[bold magenta]LAPS (Local Administrator Password Solution) Status[/bold magenta]")
    computers = [d for _, d in G.nodes(data=True) if d['type'].lower() == 'computer' and (not domain_filter or d.get('props', {}).get('domain') == domain_filter)]
    if not computers:
        console.print("[green]No computers found[/green]")
        return
    found_enabled = False
    found_disabled = False
    for d in computers:
        props = d.get('props') or {}
        laps_password = props.get('ms-mcs-admpwd') or props.get('msMcsAdmPwd')
        if laps_password:
            found_enabled = True
            console.print(f"[green]LAPS enabled[/green]: [bold cyan]{d['name']}[/bold cyan]")
        else:
            found_disabled = True
            console.print(f"[yellow]LAPS not enabled[/yellow]: [bold cyan]{d['name']}[/bold cyan]")
            add_finding("LAPS", f"Computer {d['name']} does not have LAPS enabled")
    if found_enabled:
        console.print(Panel(
            "[bold green]Impact:[/bold green] LAPS secures local admin passwords.\n"
            "[bold]Mitigation:[/bold] Ensure LAPS is enabled on all computers.\n"
            "[bold]Tools:[/bold] LAPS management tools, AD queries.",
            title="LAPS Enabled",
            border_style="green"
        ))
    if found_disabled:
        console.print(Panel(
            "[bold yellow]Impact:[/bold yellow] Local admin passwords may be weak or shared → easy compromise.\n"
            "[bold]Mitigation:[/bold] Enable LAPS to randomize and secure passwords.\n"
            "[bold]Tools:[/bold] LAPS deployment scripts.",
            title="LAPS Not Enabled",
            border_style="yellow"
        ))

# ────────────────────────────────────────────────
# Unconstrained delegation
# ────────────────────────────────────────────────
def print_unconstrained_delegation(G, domain_filter=None):
    console.rule("[bold magenta]Unconstrained Delegation Detection[/bold magenta]")
    found = False
    for n, d in G.nodes(data=True):
        if domain_filter and d.get('props', {}).get('domain') != domain_filter:
            continue
        if d['type'].lower() == 'computer':
            props = d.get('props', {})
            trusted_for_delegation = props.get('TrustedForDelegation', False)
            if trusted_for_delegation:
                found = True
                console.print(f"[yellow]Unconstrained delegation enabled[/yellow]: [bold cyan]{d['name']}[/bold cyan]")
                add_finding("Unconstrained Delegation", f"Computer {d['name']} allows unconstrained delegation", score=8)
    if found:
        print_abuse_panel("Unconstrained Delegation")  # Add this panel if desired, or reuse existing
    else:
        console.print("[green]No unconstrained delegation found[/green]")

# ────────────────────────────────────────────────
# SID History Abuse
# ────────────────────────────────────────────────
def print_sid_history_abuse(G, domain_filter=None):
    console.rule("[bold magenta]SID History Abuse[/bold magenta]")
    found = False
    high_priv_groups = {'domain admins', 'enterprise admins', 'administrators', 'schema admins'}
    for n, d in G.nodes(data=True):
        if domain_filter and d.get('props', {}).get('domain') != domain_filter:
            continue
        if d['type'].lower() != 'user':
            continue
        outgoing = list(G.out_edges(n, data=True))  # Check outgoing edges instead of incoming
        for u, v, edge_data in outgoing:
            if 'label' in edge_data and edge_data['label'].lower() == 'hassidhistory':
                group_name = G.nodes[v]['name'].lower()
                if any(hp in group_name for hp in high_priv_groups):
                    found = True
                    console.print(f"[yellow]SID History potential[/yellow]: [green]{d['name']}[/green] has SID history from [cyan]{G.nodes[v]['name']}[/cyan]")
                    add_finding("SID History Abuse", f"{d['name']} has SID history from {G.nodes[v]['name']}")
    if found:
        print_abuse_panel("SID History Abuse")
    else:
        console.print("[green]No obvious SID history abuse detected[/green]")
# ────────────────────────────────────────────────
# ADCS ESC1–ESC8 (PATCHED VERSION)
# ────────────────────────────────────────────────
def print_adcs_vulnerabilities(G, domain_filter=None):
    console.rule("[bold magenta]ADCS ESC Vulnerabilities (ESC1–ESC8)[/bold magenta]")
    found = False
    def get_bool_prop(props, keys, default=False):
        for key in keys:
            val = props.get(key.lower(), props.get(key, None))
            if val is not None:
                return bool(val)
        return default
    for n, d in G.nodes(data=True):
        if domain_filter and d.get('props', {}).get('domain') != domain_filter:
            continue
        obj_type = d.get('type', 'Unknown').lower()
        if obj_type not in ['certificate template', 'enterprise ca', 'root ca', 'ntauth store']:
            continue
        name = d.get('name') or d.get('props', {}).get('name', n)
        props = d.get('props', {}) or {}
        # Copy top-level flags to props (corrected key spelling)
        for key in ['EDITF_ATTRIBUTESUBJECTALTNAME2', 'EDITF_ATTRIBUTESUBJECTALTNAME2']:
            if key in d and key not in props:
                props[key] = d[key]
        incoming = list(G.in_edges(n, data=True))
        rights = {edge_data['label'] for _, _, edge_data in incoming}
        enrollee_supplies = get_bool_prop(props, ['enrolleesuppliessubject', 'EnrolleeSuppliesSubject'])
        requires_mgr_approval = get_bool_prop(props, ['requiresmanagerapproval', 'RequiresManagerApproval'], default=False)
        no_approval = not requires_mgr_approval
        editf_san2 = get_bool_prop(props, ['editf_attributesubjectaltname2', 'EDITF_ATTRIBUTESUBJECTALTNAME2'])
        # EKUs for ESC5/7 (placeholders; not in test data)
        ekus = props.get('ekus', []) or props.get('mspki-certificate-application-policy', [])
        has_cert_request_agent = '1.3.6.1.4.1.311.20.2.1' in ekus
        has_web_server = '1.3.6.1.5.5.7.3.1' in ekus
        # ESC1/2
        if obj_type == 'certificate template':
            if 'Enroll' in rights and enrollee_supplies and no_approval:
                found = True
                console.print(f"[red]ESC1/ESC2[/red]: [bold cyan]{name}[/bold cyan] (Enroll + EnrolleeSuppliesSubject + no approval)")
                for u, _, edge in incoming:
                    if edge['label'] == 'Enroll':
                        console.print(f"  → [green]{G.nodes[u]['name']}[/green] can Enroll")
                add_finding("ESC1-ESC8", f"ESC1/2 on {name}")
        # ESC3
        if obj_type == 'certificate template' and no_approval:
            dangerous = {'GenericAll', 'WriteDacl', 'WriteOwner', 'GenericWrite'}
            dangerous_found = dangerous & rights
            if dangerous_found:
                found = True
                console.print(f"[red]ESC3[/red]: [bold cyan]{name}[/bold cyan] (no approval + dangerous rights)")
                for u, _, edge in incoming:
                    if edge['label'] in dangerous_found:
                        console.print(f"  → [green]{G.nodes[u]['name']}[/green] --[{edge['label']}]-->")
                add_finding("ESC1-ESC8", f"ESC3 on {name}")
        # ESC4
        if obj_type in ['certificate template', 'enterprise ca', 'root ca']:
            dangerous = {'GenericAll', 'WriteDacl', 'WriteOwner', 'GenericWrite'}
            dangerous_found = dangerous & rights
            if dangerous_found:
                found = True
                console.print(f"[red]ESC4[/red]: [bold cyan]{name}[/bold cyan] (dangerous rights on PKI object)")
                for u, _, edge in incoming:
                    if edge['label'] in dangerous_found:
                        console.print(f"  → [green]{G.nodes[u]['name']}[/green] --[{edge['label']}]-->")
                add_finding("ESC1-ESC8", f"ESC4 on {name}")
        # ESC5 (placeholder)
        if obj_type == 'certificate template' and has_cert_request_agent:
            found = True
            console.print(f"[red]ESC5[/red]: [bold cyan]{name}[/bold cyan] (Certificate Request Agent EKU)")
            for u, _, edge in incoming:
                if edge['label'] == 'Enroll':
                    console.print(f"  → [green]{G.nodes[u]['name']}[/green] can Enroll")
            add_finding("ESC1-ESC8", f"ESC5 on {name}")
        # ESC6 (fixed: checks Enroll on CA)
        if obj_type == 'enterprise ca' and editf_san2 and 'Enroll' in rights:
            found = True
            console.print(f"[red]ESC6[/red]: [bold cyan]{name}[/bold cyan] (EDITF_ATTRIBUTESUBJECTALTNAME2 + Enroll)")
            for u, _, edge in incoming:
                if edge['label'] == 'Enroll':
                    console.print(f"  → [green]{G.nodes[u]['name']}[/green] can Enroll")
            add_finding("ESC1-ESC8", f"ESC6 on {name}")
        # ESC7 (placeholder)
        if obj_type == 'certificate template' and has_web_server:
            found = True
            console.print(f"[red]ESC7[/red]: [bold cyan]{name}[/bold cyan] (HTTP Certificate - Web Server EKU)")
            for u, _, edge in incoming:
                if edge['label'] == 'Enroll':
                    console.print(f"  → [green]{G.nodes[u]['name']}[/green] can Enroll")
            add_finding("ESC1-ESC8", f"ESC7 on {name}")
        # ESC8
        if obj_type == 'ntauth store' and 'GenericAll' in rights:
            found = True
            console.print(f"[red]ESC8[/red]: [bold cyan]{name}[/bold cyan] (GenericAll on NTAuth)")
            for u, _, edge in incoming:
                if edge['label'] == 'GenericAll':
                    console.print(f"  → [green]{G.nodes[u]['name']}[/green] --[GenericAll]-->")
            add_finding("ESC1-ESC8", f"ESC8 on {name}")
    if found:
        print_abuse_panel("ESC1-ESC8 (AD CS)")
    else:
        console.print("[green]No obvious ESC1–ESC8 misconfigurations detected[/green]")
        console.print("[yellow]Note: If no edges/rights are shown above, the relationships are not connected in the graph (likely ObjectIdentifier mismatch).[/yellow]")
# ────────────────────────────────────────────────
# GPO Abuse
# ────────────────────────────────────────────────
def print_gpo_abuse(G, domain_filter=None):
    console.rule("[bold magenta]GPO Abuse Risks[/bold magenta]")
    found = False
    high_value_keywords = ['domain controllers', 'domain admins', 'enterprise admins', 'administrators', 'dc']
    for n, d in G.nodes(data=True):
        if domain_filter and d.get('props', {}).get('domain') != domain_filter:
            continue
        # Case-insensitive type check
        if d['type'].lower() != 'gpo':
            continue
        name = d['name']
        incoming = list(G.in_edges(n, data=True))
        rights = {edge_data['label'].lower() for _, _, edge_data in incoming}  # Case-insensitive rights
        dangerous = {'genericall', 'writedacl', 'writeowner', 'genericwrite'}
        dangerous_found = dangerous & rights
        if dangerous_found:
            # Check for high-risk scope: Look for GPO links to high-value OUs
            is_high_risk = False
            linked_ous = []
            # Traverse outgoing edges for links (e.g., 'GpLink')
            for _, target, edge_data in G.out_edges(n, data=True):
                if edge_data.get('label', '').lower() in ['gplink', 'linkedto']:  # Adjust if needed
                    ou_name = G.nodes[target].get('name', '').lower()
                    linked_ous.append(ou_name)
                    if any(kw in ou_name for kw in high_value_keywords):
                        is_high_risk = True
            found = True
            risk_color = "[red]" if is_high_risk else "[yellow]"
            scope_note = f" (High-risk: Linked to {', '.join(linked_ous)})" if linked_ous else " (No links detected - low risk)"
            console.print(f"{risk_color}Weak GPO{risk_color}: [bold cyan]{name}[/bold cyan]{scope_note}")
            for u, _, edge in incoming:
                label_lower = edge['label'].lower()
                if label_lower in dangerous:
                    principal_name = G.nodes[u]['name']
                    console.print(f"  → [green]{principal_name}[/green] --[{edge['label']}]-->")
            add_finding("GPO Abuse", f"Weak GPO: {name}{scope_note}")
    if found:
        print_abuse_panel("GPO Abuse")
    else:
        console.print("[green]No dangerous GPO rights found[/green]")
# ────────────────────────────────────────────────
# DCSync / Replication Rights
# ────────────────────────────────────────────────
def print_dcsync_rights(G, domain_filter=None):
    console.rule("[bold magenta]DCSync / Replication Rights[/bold magenta]")
    found = False
    domain_oids = [n for n, d in G.nodes(data=True) if d['type'] == 'Domain' and (not domain_filter or d.get('props', {}).get('domain') == domain_filter)]
    if not domain_oids:
        console.print("[yellow]No domain objects found[/yellow]")
        return
    dangerous_rights = {'getchangesall', 'replicating directory changes all', 'replicating directory changes in filtered set'}  # Case-insensitive
    for domain_oid in domain_oids:
        domain_name = G.nodes[domain_oid]['name']
        incoming = G.in_edges(domain_oid, data=True)
        for u, _, d in incoming:
            label_lower = d['label'].lower()
            if label_lower in dangerous_rights:
                found = True
                principal_name = G.nodes[u]['name']
                console.print(f"[red]DCSync possible[/red]: [green]{principal_name}[/green] --[{d['label']}]--> [cyan]{domain_name}[/cyan] (Domain)")
                add_finding("DCSync", f"{principal_name} can DCSync on {domain_name}")
    if found:
        print_abuse_panel("DCSync")
    else:
        console.print("[green]No DCSync rights detected[/green]")
# ────────────────────────────────────────────────
# RBCD
# ────────────────────────────────────────────────
def print_rbcd(G, domain_filter=None):
    console.rule("[bold magenta]Resource-Based Constrained Delegation (RBCD)[/bold magenta]")
    found = False
    for n, d in G.nodes(data=True):
        if domain_filter and d.get('props', {}).get('domain') != domain_filter:
            continue
        if d['type'] != 'Computer':
            continue
        props = d.get('props', {})
        allowed_to_delegate = props.get('msds-allowedtodelegateto', [])
        if not isinstance(allowed_to_delegate, list):
            allowed_to_delegate = [allowed_to_delegate] if allowed_to_delegate else []
        if allowed_to_delegate:
            found = True
            console.print(f"[yellow]RBCD configured[/yellow]: [bold cyan]{d['name']}[/bold cyan] allows delegation from:")
            for tgt in allowed_to_delegate:
                console.print(f"  → [green]{tgt}[/green]")
            add_finding("RBCD", f"RBCD on {d['name']}")
    if found:
        print_abuse_panel("RBCD")
    else:
        console.print("[green]No RBCD configured computers found[/green]")
# ────────────────────────────────────────────────
# Shortest Paths
# ────────────────────────────────────────────────
def print_shortest_paths(G, fast=False, max_paths=10, target_filter=None, domain_filter=None, indirect=False):
    console.rule("[bold magenta]Shortest Paths to High-Value Targets[/bold magenta]")
    users = [n for n, d in G.nodes(data=True) if d['type'].lower() == 'user' and (not domain_filter or d.get('props', {}).get('domain') == domain_filter)]  # Case-insensitive
    targets = get_high_value_targets(G, domain_filter)
    if target_filter:
        targets = [t for t in targets if target_filter.lower() in t[1].lower()]  # Partial, case-insensitive match
    if not targets:
        console.print("[yellow]No high-value targets found (or none match filter)[/yellow]")
        return
    if not users:
        console.print("[yellow]No user objects found for path calculation[/yellow]")
        return
    if fast:
        console.print("[yellow]Fast mode enabled: Skipping shortest path computation[/yellow]")
        return
    for tid, tname, ttype in targets[:5]:  # Limit targets to 5 for brevity
        console.print(f"\n[bold]Target:[/bold] [bold cyan]{tname}[/bold cyan] ({ttype})")
        count = 0
        for source in users:
            if source == tid or not nx.has_path(G, source, tid):
                continue
            try:
                path = nx.shortest_path(G, source, tid)
                path_length = len(path) - 1  # Edges in path
                formatted_path = format_path(G, path)
                console.print(f"  [dim]→[/dim] (Length: {path_length}) {formatted_path}")
                count += 1
                if count >= max_paths:
                    break
            except nx.NetworkXNoPath:
                continue  # Skip silently; handled below
        # Indirect paths if requested
        if indirect:
            console.print(f"  [dim]Indirect paths (via groups):[/dim]")
            indirect_count = 0
            for source in users:
                paths = get_indirect_paths(G, source, tid)
                for path in paths:
                    formatted_path = format_path(G, path)
                    console.print(f"    [dim]→[/dim] {formatted_path}")
                    indirect_count += 1
                    if indirect_count >= max_paths:
                        break
                if indirect_count >= max_paths:
                    break
        if count == 0 and not indirect:
            # Check for connectivity issues
            connected_users = [u for u in users if nx.has_path(G, u, tid)]
            if not connected_users:
                console.print("    [dim]No paths found: Target may be disconnected from users[/dim]")
            else:
                console.print("    [dim]No paths found within limit[/dim]")
        add_finding("Shortest Paths", f"Paths to {tname}", score=6 if count > 0 else 0)
# ────────────────────────────────────────────────
# Dangerous Permissions
# ────────────────────────────────────────────────
def print_dangerous_permissions(G, domain_filter=None, indirect=False):
    console.rule("[bold magenta]Dangerous Permissions on High-Value Objects[/bold magenta]")
    dangerous_rights = {
        'genericall', 'owns', 'writedacl', 'writeowner', 'allextendedrights',
        'genericwrite', 'addmember', 'resetpassword', 'forcechangepassword',
        'manageca', 'managecertificates', 'enroll', 'certificateenroll', 'writeproperty'
    }  # Lowercase for case-insensitive matching
    targets = get_high_value_targets(G, domain_filter)
    found = False
    if not targets:
        console.print("[yellow]No high-value targets found[/yellow]")
        return
    for tid, tname, ttype in targets:
        incoming = G.in_edges(tid, data=True)
        dangerous_edges = [
            (u, d['label']) for u, v, d in incoming if 'label' in d and d['label'].lower() in dangerous_rights and u in G.nodes
        ]
        if dangerous_edges:
            found = True
            console.print(f"\n[bold cyan]{tname} ({ttype}):[/bold cyan]")
            # Group by right type for clarity
            from collections import defaultdict
            rights_by_type = defaultdict(list)
            for principal_oid, right in dangerous_edges:
                rights_by_type[right].append(principal_oid)
            for right, principals in rights_by_type.items():
                principal_names = [G.nodes[p]['name'] for p in principals[:5]]  # Limit to top 5
                count = len(principals)
                extra = f" ... and {count - 5} more" if count > 5 else ""
                console.print(f"  • [yellow]{right}[/yellow]: [green]{', '.join(principal_names)}{extra}[/green]")
            console.print(f"    [dim](Note: Only direct rights shown; indirect via groups not included)[/dim]")
            add_finding("Dangerous Permissions", f"Dangerous rights on {tname}")
    # Indirect via groups if requested
    if indirect:
        console.print(f"\n[dim]Checking indirect dangerous permissions via groups...[/dim]")
        for tid, tname, ttype in targets:
            # Find groups that have dangerous rights, then users in those groups
            for u, v, d in G.edges(data=True):
                if v == tid and 'label' in d and d['label'].lower() in dangerous_rights:
                    group_name = G.nodes[u]['name']
                    if G.nodes[u]['type'].lower() == 'group':
                        # Safe check for 'MemberOf' label in MultiDiGraph edge data
                        members = [m for m in G.predecessors(u) if any(edge_data.get('label') == 'MemberOf' for edge_data in (G.get_edge_data(m, u) or {}).values())]
                        if members:
                            console.print(f"  [yellow]Indirect via group {group_name}[/yellow]: {', '.join([G.nodes[m]['name'] for m in members[:3]])}")
    if found:
        print_abuse_panel("Dangerous Permissions")
    else:
        console.print("[green]No dangerous ACLs found on high-value objects[/green]")
# ────────────────────────────────────────────────
# Kerberoastable & AS-REP Roastable
# ────────────────────────────────────────────────
def print_kerberoastable(G, domain_filter=None):
    console.rule("[bold magenta]Kerberoastable Accounts[/bold magenta]")
    found = False
    count = 0
    max_display = 20  # Limit output to avoid overwhelm
    for n, d in G.nodes(data=True):
        if domain_filter and d.get('props', {}).get('domain') != domain_filter:
            continue
        if d['type'].lower() != 'user':  # Case-insensitive type check
            continue
        props = d.get('props', {})
        # Case-insensitive property checks with variants
        hasspn = get_bool_prop_ci(props, ['hasspn', 'hasSPN', 'has_spn'])
        sensitive = props.get('sensitive', props.get('Sensitive', False))
        enabled = props.get('enabled', props.get('Enabled', True))
        if hasspn and not sensitive and enabled:
            found = True
            console.print(f"  • [cyan]{d['name']}[/cyan]")
            count += 1
            if count >= max_display:
                remaining = sum(1 for n_inner, d_inner in G.nodes(data=True) if d_inner.get('type', '').lower() == 'user' and 
                                d_inner.get('props', {}).get('hasspn', d_inner.get('props', {}).get('hasSPN', d_inner.get('props', {}).get('has_spn', False))) and 
                                not d_inner.get('props', {}).get('sensitive', d_inner.get('props', {}).get('Sensitive', False)) and 
                                d_inner.get('props', {}).get('enabled', d_inner.get('props', {}).get('Enabled', True))) - max_display
                if remaining > 0:
                    console.print(f"  [dim]... and {remaining} more[/dim]")
                break
    if found:
        print_abuse_panel("Kerberoastable")
        add_finding("Kerberoastable", f"{count} accounts")
    else:
        console.print("[green]None found[/green]")


def print_as_rep_roastable(G, domain_filter=None):
    console.rule("[bold magenta]AS-REP Roastable Accounts (DONT_REQ_PREAUTH)[/bold magenta]")
    found = False
    count = 0
    max_display = 20  # Limit output to avoid overwhelm
    for n, d in G.nodes(data=True):
        if domain_filter and d.get('props', {}).get('domain') != domain_filter:
            continue
        if d['type'].lower() != 'user':  # Case-insensitive type check
            continue
        props = d.get('props', {})
        # Case-insensitive property checks with variants
        dontreqpreauth = get_bool_prop_ci(props, ['dontreqpreauth', 'dontReqPreauth', 'dont_req_preauth'])
        sensitive = props.get('sensitive', props.get('Sensitive', False))
        enabled = props.get('enabled', props.get('Enabled', True))
        if dontreqpreauth and not sensitive and enabled:
            found = True
            console.print(f"  • [cyan]{d['name']}[/cyan]")
            count += 1
            if count >= max_display:
                remaining = sum(1 for n_inner, d_inner in G.nodes(data=True) if d_inner.get('type', '').lower() == 'user' and 
                                d_inner.get('props', {}).get('dontreqpreauth', d_inner.get('props', {}).get('dontReqPreauth', d_inner.get('props', {}).get('dont_req_preauth', False))) and 
                                not d_inner.get('props', {}).get('sensitive', d_inner.get('props', {}).get('Sensitive', False)) and 
                                d_inner.get('props', {}).get('enabled', d_inner.get('props', {}).get('Enabled', True))) - max_display
                if remaining > 0:
                    console.print(f"  [dim]... and {remaining} more[/dim]")
                break
    if found:
        print_abuse_panel("AS-REP Roastable")
        add_finding("AS-REP Roastable", f"{count} accounts")
    else:
        console.print("[green]None found[/green]")

# ────────────────────────────────────────────────
# Sessions / LocalAdmin
# ────────────────────────────────────────────────
def print_sessions_localadmin(G, domain_filter=None):
    console.rule("[bold magenta]Session / LocalAdmin Summary[/bold magenta]")
    computers = [n for n, d in G.nodes(data=True) if d['type'].lower() == 'computer' and (not domain_filter or d.get('props', {}).get('domain') == domain_filter)]  # Case-insensitive type check
    if not computers:
        console.print("[yellow]No computers with session data[/yellow]")
        return
    table = Table(title="Top Local Admins", show_header=True, header_style="bold magenta")
    table.add_column("Principal", style="cyan")
    table.add_column("Count", justify="right")
    table.add_column("Examples", style="green")
    from collections import Counter
    # Filter edges: label == 'LocalAdmin' and target (v) is a Computer
    admin_edges = [(u, v, d) for u, v, d in G.edges(data=True) if d.get('label') == 'LocalAdmin' and v in computers and u in G.nodes and v in G.nodes]
    counts = Counter(u for u, _, _ in admin_edges)
    if not counts:
        console.print("[green]No LocalAdmin rights found[/green]")
        return
    for principal, count in counts.most_common(10):
        examples = [G.nodes[v]['name'] for pu, v, _ in admin_edges if pu == principal][:3]
        table.add_row(G.nodes[principal]['name'], str(count), ", ".join(examples))
    console.print(table)
    total_admins = sum(counts.values())
    console.print(f"[dim]Total LocalAdmin instances: {total_admins} on {len(computers)} computers[/dim]")
# ────────────────────────────────────────────────
# Export
# ────────────────────────────────────────────────
def export_results(G, output_prefix="bloodbash", format_type="md", domain_filter=None):
    if format_type == "md":
        path = f"{output_prefix}.md"
        with open(path, "w", encoding="utf-8") as f:
            f.write("# BloodBash Report\n\n")
            f.write("## High-Value Targets\n")
            for _, name, typ in get_high_value_targets(G, domain_filter):
                f.write(f"- {name} ({typ})\n")
            f.write("\n## Sample Paths\n")
            # Add sample paths
            f.write("See console output for details.\n")
        console.print(f"[green]Exported Markdown:[/green] {path}")
    elif format_type == "json":
        path = f"{output_prefix}.json"
        summary = {
            "nodes": G.number_of_nodes(),
            "edges": G.number_of_edges(),
            "high_value": [
                {"name": d['name'], "type": d['type']} for _, d in G.nodes(data=True)
                if any(k in d['name'].lower() for k in ['admin', 'krbtgt', 'ca', 'template']) and (not domain_filter or d.get('props', {}).get('domain') == domain_filter)
            ]
        }
        with open(path, "w", encoding="utf-8") as f:
            json.dump(summary, f, indent=2)
        console.print(f"[green]Exported JSON:[/green] {path}")
    elif format_type == "html":
        path = f"{output_prefix}.html"
        html = f"""<html><head><title>BloodBash Report</title><style>
        body {{ font-family: Arial; }}
        .red {{ color: red; }}
        .yellow {{ color: orange; }}
        .green {{ color: green; }}
        table {{ border-collapse: collapse; }}
        th, td {{ border: 1px solid black; padding: 5px; }}
        </style></head><body>
        <h1>BloodBash Report</h1>
        <h2>High-Value Targets</h2><ul>"""
        for _, name, typ in get_high_value_targets(G, domain_filter):
            html += f"<li>{escape(name)} ({escape(typ)})</li>"
        html += "</ul><h2>Prioritized Findings</h2><table><tr><th>Severity</th><th>Category</th><th>Details</th></tr>"
        for score, cat, det in sorted(global_findings, key=lambda x: x[0], reverse=True):
            html += f"<tr><td>{score}</td><td>{escape(cat)}</td><td>{escape(det)}</td></tr>"
        html += "</table></body></html>"
        with open(path, "w", encoding="utf-8") as f:
            f.write(html)
        console.print(f"[green]Exported HTML:[/green] {path}")
    elif format_type == "csv":
        path = f"{output_prefix}_sessions.csv"
        with open(path, "w", newline="", encoding="utf-8") as f:
            writer = csv.writer(f)
            writer.writerow(["Principal", "Count", "Examples"])
            # Example: Export sessions table
            from collections import Counter
            computers = [n for n, d in G.nodes(data=True) if d['type'].lower() == 'computer' and (not domain_filter or d.get('props', {}).get('domain') == domain_filter)]
            admin_edges = [(u, v, d) for u, v, d in G.edges(data=True) if d.get('label') == 'LocalAdmin' and v in computers]
            counts = Counter(u for u, _, _ in admin_edges)
            for principal, count in counts.most_common(10):
                examples = [G.nodes[v]['name'] for pu, v, _ in admin_edges if pu == principal][:3]
                writer.writerow([G.nodes[principal]['name'], count, ", ".join(examples)])
        console.print(f"[green]Exported CSV:[/green] {path}")
    elif format_type == "yaml":
        path = f"{output_prefix}.yaml"
        summary = {
            "nodes": G.number_of_nodes(),
            "edges": G.number_of_edges(),
            "high_value": [
                {"name": d['name'], "type": d['type']} for _, d in G.nodes(data=True)
                if any(k in d['name'].lower() for k in ['admin', 'krbtgt', 'ca', 'template']) and (not domain_filter or d.get('props', {}).get('domain') == domain_filter)
            ],
            "findings": [{"score": s, "category": c, "details": d} for s, c, d in global_findings]
        }
        with open(path, "w", encoding="utf-8") as f:
            yaml.dump(summary, f, default_flow_style=False)
        console.print(f"[green]Exported YAML:[/green] {path}")
# ────────────────────────────────────────────────
# Main
# ────────────────────────────────────────────────
def main():
    parser = argparse.ArgumentParser(description="BloodBash - Advanced BloodHound Analyzer with Abuse Suggestions")
    parser.add_argument('directory', nargs='?', default='.', help='Path to SharpHound JSON files')
    parser.add_argument('--shortest-paths', action='store_true')
    parser.add_argument('--dangerous-permissions', action='store_true')
    parser.add_argument('--adcs', action='store_true')
    parser.add_argument('--gpo-abuse', action='store_true')
    parser.add_argument('--dcsync', action='store_true')
    parser.add_argument('--rbcd', action='store_true')
    parser.add_argument('--sessions', action='store_true')
    parser.add_argument('--kerberoastable', action='store_true')
    parser.add_argument('--as-rep-roastable', action='store_true')
    parser.add_argument('--sid-history', action='store_true')
    parser.add_argument('--unconstrained-delegation', action='store_true')
    parser.add_argument('--password-descriptions', action='store_true')
    parser.add_argument('--password-never-expires', action='store_true')
    parser.add_argument('--password-not-required', action='store_true')
    parser.add_argument('--shadow-credentials', action='store_true')
    parser.add_argument('--gpo-parsing', action='store_true')
    parser.add_argument(
        "--gpo-content-dir",
        type=str,
        default=None,
        help="Directory containing GPO XML reports (e.g. from Get-GPOReport -ReportType Xml) for content analysis"
    )
    parser.add_argument('--constrained-delegation', action='store_true')
    parser.add_argument('--laps', action='store_true')
    parser.add_argument('--verbose', action='store_true')
    parser.add_argument('--all', action='store_true')
    parser.add_argument('--export', nargs='?', const='md', choices=['md', 'json', 'html', 'csv', 'yaml'], help='Export results')
    parser.add_argument('--fast', action='store_true', help='Fast mode (skip heavy pathfinding)')
    parser.add_argument('--domain', help='Filter by domain')
    parser.add_argument('--indirect', action='store_true', help='Include indirect paths/permissions')
    parser.add_argument('--db', help='SQLite DB path for persistence (save/load graph)')
    args = parser.parse_args()
    start_time = time.time()
    if args.db and os.path.exists(args.db):
        G, name_to_oid = load_graph_from_db(args.db)
    else:
        nodes = load_json_dir(args.directory)
        if not nodes:
            console.print("[red]No objects loaded. Exiting.[/red]")
            sys.exit(1)
        G, name_to_oid = build_graph(nodes, args.db if args.db else None)
    # Determine mode string for banner
    if args.all:
        mode_str = "Full analysis (--all)"
    elif any([args.shortest_paths, args.dangerous_permissions, args.adcs, args.gpo_abuse,
              args.dcsync, args.rbcd, args.sessions, args.kerberoastable, args.as_rep_roastable, args.sid_history, args.unconstrained_delegation, args.password_descriptions, args.password_never_expires, args.password_not_required, args.shadow_credentials, args.gpo_parsing, args.constrained_delegation, args.laps]):
        mode_str = "Selected checks"
    else:
        mode_str = "Default (verbose summary + common checks)"
    print_intro_banner(mode_str)
    run_all = args.all or not any([
        args.shortest_paths, args.dangerous_permissions, args.adcs, args.gpo_abuse,
        args.dcsync, args.rbcd, args.sessions, args.kerberoastable, args.as_rep_roastable, args.sid_history, args.unconstrained_delegation, args.password_descriptions, args.password_never_expires, args.password_not_required, args.shadow_credentials, args.gpo_parsing, args.constrained_delegation, args.laps
    ])
    if args.verbose or run_all:
        print_verbose_summary(G, args.domain)
    if args.shortest_paths or run_all:
        print_shortest_paths(G, fast=args.fast, domain_filter=args.domain, indirect=args.indirect)
    if args.dangerous_permissions or run_all:
        print_dangerous_permissions(G, args.domain, args.indirect)
    if args.adcs or run_all:
        print_adcs_vulnerabilities(G, args.domain)
    if args.gpo_abuse or run_all:
        print_gpo_abuse(G, args.domain)
    if args.dcsync or run_all:
        print_dcsync_rights(G, args.domain)
    if args.rbcd or run_all:
        print_rbcd(G, args.domain)
    if args.sessions or run_all:
        print_sessions_localadmin(G, args.domain)
    if args.kerberoastable or run_all:
        print_kerberoastable(G, args.domain)
    if args.as_rep_roastable or run_all:
        print_as_rep_roastable(G, args.domain)
    if args.sid_history or run_all:
        print_sid_history_abuse(G, args.domain)
    if args.unconstrained_delegation or run_all:
        print_unconstrained_delegation(G, args.domain)
    if args.password_descriptions or run_all:
        print_password_in_descriptions(G, args.domain)
    if args.password_never_expires or run_all:
        print_password_never_expires(G, args.domain)
    if args.password_not_required or run_all:
        print_password_not_required(G, args.domain)
    if args.shadow_credentials or run_all:
        print_shadow_credentials(G, args.domain)
    if args.gpo_parsing or run_all:
        print_gpo_content_parsing(G, args.domain)
    if args.constrained_delegation or run_all:
        print_constrained_delegation(G, args.domain)
    if args.laps or run_all:
        print_laps_status(G, args.domain)
#    if args.all or args.gpo_content_dir:
#        print_gpo_content_analysis(G, args)
    if args.export:
        export_results(G, format_type=args.export, domain_filter=args.domain)


    print_prioritized_findings()
    elapsed = time.time() - start_time
    console.print(f"\n[italic green]Completed in {elapsed:.2f} seconds[/italic green]")

if __name__ == '__main__':
    main()
